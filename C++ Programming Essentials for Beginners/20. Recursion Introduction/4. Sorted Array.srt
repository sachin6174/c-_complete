1
00:00:01,080 --> 00:00:01,880
Hi, everyone.

2
00:00:02,040 --> 00:00:07,800
Now we have already looked at two examples in which we used the occasion to bring the solution.

3
00:00:08,520 --> 00:00:13,260
Now we're going to look at the third question in which we had not given a number, but we have to work

4
00:00:13,260 --> 00:00:14,100
on an OK.

5
00:00:14,130 --> 00:00:21,260
For example, we need to write a recursive function that checks whether a given error is sorted or not.

6
00:00:21,270 --> 00:00:21,540
OK?

7
00:00:21,720 --> 00:00:24,210
So you would think how do I apply to college in 1980?

8
00:00:24,510 --> 00:00:25,650
That idea is very simple.

9
00:00:25,890 --> 00:00:33,060
Like we say, for the problem of say, then we can break it into one one work by noon, what we will

10
00:00:33,060 --> 00:00:39,240
do and remaining in minus one units of work that goes in very similar thing.

11
00:00:39,390 --> 00:00:40,650
We can apply here as well.

12
00:00:41,100 --> 00:00:43,560
So let's see how we can actually handle this problem.

13
00:00:44,160 --> 00:00:47,130
So let us let me draw NRT.

14
00:00:47,920 --> 00:00:58,210
And let's say we have certain elements, let's say one, two, three, five, four and six two.

15
00:00:58,410 --> 00:01:00,950
This is the area, and I want to check if we decided on North.

16
00:01:02,150 --> 00:01:03,260
Now what you can do is.

17
00:01:04,790 --> 00:01:09,440
The first step you can take and you can ask it, it goes in to tell whether the remaining that is ordered

18
00:01:09,440 --> 00:01:09,750
or not.

19
00:01:09,780 --> 00:01:15,560
OK, so the first step would be you compared the first the 02 11 with the first element that you take.

20
00:01:16,070 --> 00:01:23,420
If one is less than two and the remaining that is sorted, then you can say that indeed it is going

21
00:01:23,420 --> 00:01:23,990
to be sorted.

22
00:01:24,000 --> 00:01:27,380
OK, so what is the condition for area of say?

23
00:01:27,380 --> 00:01:35,000
Then let's say you have an idea of size and you can check it is sorted if area of zero is less than

24
00:01:35,000 --> 00:01:35,720
ideal one.

25
00:01:36,140 --> 00:01:36,440
OK.

26
00:01:37,220 --> 00:01:41,420
And let's say there is a function that returns, whether it is altered or not.

27
00:01:41,450 --> 00:01:45,770
So what we will need to do, we need to check if this is the case and.

28
00:01:46,920 --> 00:01:53,670
The remaining areas also started, OK, the remaining areas of the size and minus one, if it is, if

29
00:01:53,670 --> 00:01:59,550
it is all decided, then we can say yes, then that it is going to be OK, this is what I'm going to

30
00:01:59,550 --> 00:01:59,830
tell you.

31
00:01:59,850 --> 00:02:04,020
One is less than two and two three five four six.

32
00:02:04,260 --> 00:02:05,370
This is the remaining area.

33
00:02:05,880 --> 00:02:08,010
Is this area sorted again?

34
00:02:08,400 --> 00:02:09,630
I will make a recursive call.

35
00:02:09,660 --> 00:02:11,160
OK, so I am breaking down this call.

36
00:02:11,550 --> 00:02:12,780
It was less than three years.

37
00:02:13,620 --> 00:02:18,090
Then we will make a call on the remaining grid that is the five or six.

38
00:02:19,140 --> 00:02:25,740
Then we break it down now for this area, is it it is less than even yes, three is less than five and

39
00:02:25,740 --> 00:02:26,520
we can check.

40
00:02:27,750 --> 00:02:32,400
That the remaining that is 546, is it sorted or not?

41
00:02:33,640 --> 00:02:37,730
Now, at this point, we're going to take is five less than four done to this?

42
00:02:37,920 --> 00:02:38,650
No, OK.

43
00:02:39,160 --> 00:02:46,510
As soon as we get this anthrax, no, we don't need to make any further calls and we can return calls

44
00:02:46,510 --> 00:02:47,580
from this particular point.

45
00:02:47,590 --> 00:02:48,950
So this basically tells, OK.

46
00:02:48,970 --> 00:02:50,050
This condition is false.

47
00:02:50,710 --> 00:02:53,080
It tells its parent that this condition is false.

48
00:02:53,540 --> 00:02:55,690
Where we are doing it and of proven false.

49
00:02:55,810 --> 00:02:58,150
That means that output would be false.

50
00:02:58,660 --> 00:03:05,470
That we are doing and of proven false output would be false and hence to the main goal.

51
00:03:05,470 --> 00:03:08,650
We will look at knowing this error is not sorted and we are going to return.

52
00:03:09,680 --> 00:03:12,880
This is the case for Linda.

53
00:03:12,880 --> 00:03:13,900
It is not sorted.

54
00:03:14,330 --> 00:03:18,940
Now let us also look at the case when it is not what is going to happen.

55
00:03:19,270 --> 00:03:24,500
Let's let me take a small example one, two, three and legs of life.

56
00:03:25,210 --> 00:03:27,280
We are going to take one is less than two.

57
00:03:27,550 --> 00:03:29,230
Yes, remaining.

58
00:03:29,230 --> 00:03:29,890
It is sorted.

59
00:03:30,070 --> 00:03:31,660
We don't know because it will take.

60
00:03:32,080 --> 00:03:32,580
It will take.

61
00:03:32,590 --> 00:03:33,520
Those less than three.

62
00:03:34,060 --> 00:03:35,290
Is the remaining resorted?

63
00:03:35,920 --> 00:03:40,660
We don't know the is going to take these lives than faith and is the remaining resorted.

64
00:03:42,430 --> 00:03:44,020
Remaining, it is only one element.

65
00:03:44,050 --> 00:03:45,850
Yes, it's one element that is sorted.

66
00:03:46,240 --> 00:03:47,010
This is true.

67
00:03:47,060 --> 00:03:48,490
This is true, tried and true.

68
00:03:49,060 --> 00:03:49,720
This is true.

69
00:03:49,720 --> 00:03:50,240
This is true.

70
00:03:50,240 --> 00:03:51,160
It returns true.

71
00:03:51,520 --> 00:03:52,090
This is true.

72
00:03:52,090 --> 00:03:52,660
This is true.

73
00:03:52,660 --> 00:03:53,650
It returns true.

74
00:03:53,950 --> 00:03:57,850
And this ad is going to be sorted now from here, you can figure out.

75
00:03:58,210 --> 00:04:02,080
The base case, though, if only one element is left.

76
00:04:03,300 --> 00:04:06,860
Then you can say, yes, it is us or today, OK?

77
00:04:07,530 --> 00:04:10,210
In the recursive case, you have to check for two conditions.

78
00:04:10,230 --> 00:04:12,720
One is if a zero is less than even.

79
00:04:14,240 --> 00:04:16,880
And the remaining area is sorted.

80
00:04:17,060 --> 00:04:17,360
OK.

81
00:04:17,990 --> 00:04:23,420
The remaining at it, you can make a recursive call to check whether that date is sorted or not.

82
00:04:24,050 --> 00:04:26,510
So that's all for this concept.

83
00:04:26,640 --> 00:04:28,340
And now we will look into the cold.

84
00:04:31,560 --> 00:04:34,710
I so now let's see the goal for this problem.

85
00:04:35,550 --> 00:04:38,800
Whether that is or so, there are multiple ways to write the goal.

86
00:04:38,820 --> 00:04:45,480
I'm going to discuss three of the OK, so in the first function, I'm going to write a Mulund function

87
00:04:45,480 --> 00:04:48,280
that tells whether this water does not take input.

88
00:04:48,330 --> 00:04:52,890
The edit and I also take input the number of elements the arrays currently contain.

89
00:04:52,950 --> 00:04:53,250
OK.

90
00:04:53,670 --> 00:04:56,580
We talked about we will have a base case I'm going to talk about.

91
00:04:56,580 --> 00:04:57,900
We will have a recursive case.

92
00:04:58,620 --> 00:04:59,990
What happened in the base case?

93
00:05:00,000 --> 00:05:07,860
We said if only one element is left or maybe the elements are there and they, then it would be sorted

94
00:05:07,860 --> 00:05:09,750
out so I can return to that.

95
00:05:09,750 --> 00:05:15,540
What we have already discussed in the recursive case we talked about, we will check if at zero.

96
00:05:16,610 --> 00:05:18,680
Is less than a day off one.

97
00:05:19,870 --> 00:05:27,010
And the remaining that sorted, it sorted the remaining three, OK, so now let's say this is the area.

98
00:05:28,730 --> 00:05:34,990
And the remaining that I want to guard from this particular point, I can pass this point as Europe

99
00:05:35,000 --> 00:05:42,710
as one because it will take my edit starting address for the remaining problem to the next index, so

100
00:05:42,710 --> 00:05:47,660
I can check if the edit that starts from anyplace +1 is sorted.

101
00:05:48,020 --> 00:05:52,460
And this edit contains how many elements this contain, then minus one elements.

102
00:05:52,460 --> 00:05:56,150
OK, if this is the case, then I can say return true.

103
00:05:56,480 --> 00:05:59,690
If one of these conditions is false, then I can return false.

104
00:06:00,230 --> 00:06:00,700
That's it.

105
00:06:00,710 --> 00:06:02,240
That's the entire goal.

106
00:06:02,660 --> 00:06:06,350
Now we can try to run and check for this example.

107
00:06:06,560 --> 00:06:07,820
Maybe I can.

108
00:06:07,820 --> 00:06:13,790
To see out is sorted and I give the Eddie and I give the relevant.

109
00:06:16,150 --> 00:06:18,850
Let's build a gold and let's try to run it.

110
00:06:19,200 --> 00:06:23,920
So Dodge started artillery and I'm getting a zero.

111
00:06:23,920 --> 00:06:25,580
That means this ad is not sorted.

112
00:06:25,600 --> 00:06:27,730
Maybe a let me make it as.

113
00:06:29,790 --> 00:06:30,530
Six, seven.

114
00:06:31,110 --> 00:06:31,590
Then.

115
00:06:32,530 --> 00:06:35,320
I should get an answer, one that yes, this ad is.

116
00:06:36,130 --> 00:06:39,130
Now you're going to Discord is working perfectly fine.

117
00:06:39,580 --> 00:06:44,140
And this is exactly how we have discussed and the code should be implemented, OK?

118
00:06:44,500 --> 00:06:47,560
So some people may find another way to implement it.

119
00:06:47,590 --> 00:06:49,490
Let me also go through that way.

120
00:06:50,080 --> 00:06:56,940
Some people may find this error plus one and then minus one consuming confusing, then maybe is sorted.

121
00:06:57,140 --> 00:07:00,070
And you may like to buy an index.

122
00:07:01,210 --> 00:07:01,500
OK.

123
00:07:02,020 --> 00:07:08,470
Let me tell you one more way in this way, you're not changing the value of and so what we're going

124
00:07:08,470 --> 00:07:12,670
to do, we are going to pass the address in the form of an index.

125
00:07:12,670 --> 00:07:20,950
OK, let's say we're checking whether Adelphi is less than ideal 5+1 and we can say, OK, let us check

126
00:07:21,280 --> 00:07:25,300
the remaining sub area that starts from my plus one is sorted or not, OK?

127
00:07:25,510 --> 00:07:30,160
And when it reaches this value, OK, we're going to mix up problems.

128
00:07:30,160 --> 00:07:31,210
Our problems are problems.

129
00:07:31,210 --> 00:07:34,900
The problem, then, is equal to and minus one.

130
00:07:34,900 --> 00:07:38,470
That means we have added, which contains exactly one element.

131
00:07:39,100 --> 00:07:45,340
So let me write the same code in a different manner so I can check if I equals in minus one.

132
00:07:45,370 --> 00:07:48,190
That means we are at the last index we can return to.

133
00:07:49,360 --> 00:07:51,010
That is ways we can check if.

134
00:07:52,560 --> 00:07:54,730
If is less than a day off.

135
00:07:55,020 --> 00:08:02,130
+1 and the remaining areas sorted is sorted or maybe is sorted to.

136
00:08:03,900 --> 00:08:04,860
This is a second way.

137
00:08:05,640 --> 00:08:11,310
Then we pass in the area instead of changing the area, address what we can do, we can move the index

138
00:08:11,310 --> 00:08:12,600
point one step forward.

139
00:08:13,050 --> 00:08:14,100
That is a plus one.

140
00:08:14,760 --> 00:08:19,620
And instead of reducing the size, often we can do the erase from my plus one bill and minus one.

141
00:08:19,650 --> 00:08:23,790
So we keep it as in and we can check we can get it done through true.

142
00:08:24,300 --> 00:08:26,100
Otherwise we can return Dunford's.

143
00:08:26,640 --> 00:08:29,370
This could be another way of writing.

144
00:08:34,840 --> 00:08:35,070
OK.

145
00:08:35,860 --> 00:08:37,360
What is not declared?

146
00:08:42,120 --> 00:08:43,340
But this should be better.

147
00:08:43,380 --> 00:08:44,240
This should be a at.

148
00:08:45,430 --> 00:08:48,950
So maybe I can call this method is sorted.

149
00:08:48,970 --> 00:08:49,330
Do.

150
00:08:51,570 --> 00:08:55,500
And here I need to pass in value if I initially there's going to be zero.

151
00:08:56,340 --> 00:08:59,280
And if I'd underscore now I get it sorted.

152
00:08:59,700 --> 00:09:05,610
But suppose if I put it 16 here and I and this meant now you can say it is going to return zero.

153
00:09:06,540 --> 00:09:14,880
So what the methods are almost saying, the only thing is in the first method, we are not explicitly

154
00:09:14,880 --> 00:09:15,930
passing the address.

155
00:09:16,230 --> 00:09:16,980
We had a.

156
00:09:18,060 --> 00:09:23,790
Ending the base address of daddy in every call, we are making a copy of the address and we are updating

157
00:09:23,790 --> 00:09:23,970
it.

158
00:09:24,780 --> 00:09:28,980
OK, but in the second address, instead of changing the base address of the we have kept agreeable

159
00:09:29,010 --> 00:09:34,130
eye, which tells us in the current function call, we are going to start over area from an index site

160
00:09:34,170 --> 00:09:37,740
and we are going to do the work and minus one.

161
00:09:37,860 --> 00:09:45,630
OK, so that's all for the two approaches, and I hope the goals are very simple and they should be

162
00:09:45,630 --> 00:09:46,380
clear to you now.

163
00:09:47,640 --> 00:09:48,860
That's all for this lecture.

164
00:09:48,870 --> 00:09:49,350
Thank you.
