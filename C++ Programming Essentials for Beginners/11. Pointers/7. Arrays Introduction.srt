1
00:00:01,830 --> 00:00:02,580
Hello, everyone.

2
00:00:02,700 --> 00:00:07,890
Welcome to this section on that is in this section, we will talk about our first date as a chair of

3
00:00:07,890 --> 00:00:10,020
this course that is known as edit.

4
00:00:10,590 --> 00:00:16,650
And it's a very simple, very useful data subject, and it has a lot of Real-Life use case as well.

5
00:00:17,100 --> 00:00:18,250
So what is it?

6
00:00:18,510 --> 00:00:22,250
So you must have learned about a variable in the programming language.

7
00:00:22,260 --> 00:00:23,220
So what is a variable?

8
00:00:23,370 --> 00:00:26,220
Variable is a bucket that stores some data.

9
00:00:26,220 --> 00:00:31,650
For example, I want to store the number of friends I have.

10
00:00:31,910 --> 00:00:39,690
I can create a number, a variable of the type in digit, and this variable will store, OK, I have

11
00:00:39,840 --> 00:00:44,800
five best friends that will store this inside a particular memory.

12
00:00:45,300 --> 00:00:48,420
But suppose we have something complex.

13
00:00:48,420 --> 00:00:55,380
We want to store marks off students and we want to store marks of Let's 100 students, OK?

14
00:00:55,950 --> 00:00:58,890
What we need, we need is a collection of elements.

15
00:00:59,010 --> 00:00:59,340
OK.

16
00:01:00,120 --> 00:01:01,680
We cannot create 100 variables.

17
00:01:02,040 --> 00:01:04,160
But what we will create is an area.

18
00:01:04,170 --> 00:01:06,420
OK, so let's create an area like this.

19
00:01:06,840 --> 00:01:12,150
So we called this has little marks on each index.

20
00:01:12,600 --> 00:01:15,210
OK, so this area is indexed from zero.

21
00:01:16,110 --> 00:01:18,540
Let's see if it does having the size of 100.

22
00:01:18,960 --> 00:01:23,170
Then these are 100 buckets which are lying linearly in the memory.

23
00:01:23,250 --> 00:01:30,660
So this linear collection of elements is known as the last index would be 999, and we can say we have

24
00:01:30,660 --> 00:01:34,590
100 buckets which are lined linearly in the memory.

25
00:01:34,940 --> 00:01:38,710
Similarly, I can say this looks like an area off.

26
00:01:39,120 --> 00:01:40,260
That's OK.

27
00:01:41,070 --> 00:01:46,860
Instead of having a simple data type, we are having a different kind of day where each element.

28
00:01:48,130 --> 00:01:52,330
Is it is of the type God and each God can have different attributes?

29
00:01:52,540 --> 00:01:56,290
Maybe a god height, maybe a guard color, maybe a guard type, OK?

30
00:01:56,650 --> 00:01:59,560
But for now, let's just focus on symbol symbol.

31
00:01:59,770 --> 00:02:05,310
Let's say you want to store the marks of every student out of 100 may be destroyed in God.

32
00:02:05,350 --> 00:02:05,910
Eighty nine.

33
00:02:06,310 --> 00:02:07,570
This God 78.

34
00:02:07,570 --> 00:02:08,650
This God 32.

35
00:02:08,650 --> 00:02:09,820
This God of physics.

36
00:02:10,950 --> 00:02:11,850
And so on.

37
00:02:12,000 --> 00:02:14,560
OK, maybe this got 84.

38
00:02:15,300 --> 00:02:20,250
So what will happen is how you're going to read the city, how you're going to write this very.

39
00:02:20,250 --> 00:02:28,150
We're just going to sit down and you can access marks of any student by writing marks off I.

40
00:02:28,350 --> 00:02:28,700
OK.

41
00:02:29,160 --> 00:02:29,940
What are you going to do?

42
00:02:29,970 --> 00:02:38,520
You can access the IoT market by using this notation marks of fire so you can perform different operations.

43
00:02:38,670 --> 00:02:42,240
For example, you can read what are the marks of diet student?

44
00:02:42,570 --> 00:02:45,390
You can update what are the marks of that student?

45
00:02:45,660 --> 00:02:46,930
You can even output.

46
00:02:47,280 --> 00:02:49,650
What are the marks of the IoT student?

47
00:02:50,100 --> 00:02:56,550
Let us talk a little bit about areas, so it is a collection of elements of the same type list in a

48
00:02:56,550 --> 00:02:58,140
continuous memory location.

49
00:02:58,140 --> 00:03:01,830
OK, so these are the two important things you should remember.

50
00:03:02,610 --> 00:03:08,340
The they should have elements of the same day, but in some other languages like Python, you can have

51
00:03:08,970 --> 00:03:09,420
a Google.

52
00:03:09,420 --> 00:03:13,620
Indeed, as a tourist card, as a list and list is heterogeneous in Python, OK?

53
00:03:13,890 --> 00:03:19,060
But in C++ and in Java these areas, all the elements should be of the same type.

54
00:03:19,080 --> 00:03:24,860
That means you cannot put a string and in digit inside the same eddy.

55
00:03:24,900 --> 00:03:25,260
OK.

56
00:03:25,470 --> 00:03:30,540
If you want to store data like this, you also need to convert this into a string.

57
00:03:30,570 --> 00:03:32,340
Everything should be of the same type.

58
00:03:33,300 --> 00:03:33,500
OK?

59
00:03:33,840 --> 00:03:36,210
And they are placed in a continuous memory location.

60
00:03:36,210 --> 00:03:45,930
That means each bucket is, let's say, if each reader is digging for bytes and if this address of the

61
00:03:45,930 --> 00:03:50,610
memory is 100, then the next address will be one zero for the next, but would be one zero eight.

62
00:03:50,640 --> 00:03:53,670
The next address would be one one, 12 and so on.

63
00:03:53,700 --> 00:03:58,300
OK, so that means it is light linearly inside the memory.

64
00:03:58,320 --> 00:04:05,580
OK, now we will look at how we can perform different operations on it, in how we can create input

65
00:04:05,580 --> 00:04:07,350
output and update.

66
00:04:08,280 --> 00:04:13,230
So one more thing I want to talk about is let us talk about correct that it is OK.

67
00:04:14,270 --> 00:04:15,180
So in character.

68
00:04:16,050 --> 00:04:24,050
Each character has a size of one bite instead of having this memory of size for bites like we have in

69
00:04:24,050 --> 00:04:29,180
the case of our invaded, this memories of the type one bite.

70
00:04:29,240 --> 00:04:32,960
OK, so if this but is hundred, the next day address will be one zero one.

71
00:04:32,960 --> 00:04:34,700
The next address will be one zero two.

72
00:04:35,210 --> 00:04:39,080
And this is how we can store our characters inside a particular areas.

73
00:04:39,080 --> 00:04:39,450
So face.

74
00:04:39,500 --> 00:04:42,740
OK, give me an idea of one.

75
00:04:42,830 --> 00:04:47,240
So that means that even what we have it will print me, OK?

76
00:04:47,540 --> 00:04:53,140
B, as a character, look at each position, we can store a single character and this can be any character,

77
00:04:53,150 --> 00:04:53,390
OK?

78
00:04:53,750 --> 00:04:56,390
So in an ideal case, we will see later.

79
00:04:56,390 --> 00:05:02,830
Also, these character traits should be terminated by a special character that is known as another character.

80
00:05:02,840 --> 00:05:03,080
OK?

81
00:05:03,470 --> 00:05:05,580
So this is something you should not forget.

82
00:05:05,600 --> 00:05:07,730
You should always put no character.

83
00:05:08,790 --> 00:05:14,010
At the end of the victory, so we will see why it is needed and why it is helpful.

84
00:05:15,050 --> 00:05:17,540
Let us talk a little bit about invigilators first.

85
00:05:17,990 --> 00:05:21,860
So this court example shows you how you can create dirty.

86
00:05:22,220 --> 00:05:26,690
So here we are, creating an area and we are telling the compiler that you should allocate.

87
00:05:28,450 --> 00:05:29,400
Memory of.

88
00:05:30,830 --> 00:05:37,640
How much space I need 100 boxes and sensors of the type in digit, each integer takes four bytes, so

89
00:05:37,640 --> 00:05:38,960
it would be four and 200.

90
00:05:39,680 --> 00:05:44,480
It will allocate a linear memory of 400 bytes when your program is being.

91
00:05:46,360 --> 00:05:52,540
Come by, it'll get so the kind of education we are doing, it is known as static memory allocation.

92
00:05:52,540 --> 00:05:56,980
We defining the size before the program is executed.

93
00:05:56,980 --> 00:06:02,260
We are not defining the size on a random, so we had a statically allocating these eddies.

94
00:06:02,860 --> 00:06:04,030
And here what we are doing.

95
00:06:04,030 --> 00:06:05,500
We are creating error.

96
00:06:05,950 --> 00:06:06,280
OK.

97
00:06:06,640 --> 00:06:08,090
And it has elements.

98
00:06:08,380 --> 00:06:12,640
And the first element of the error is initialized with zero.

99
00:06:13,390 --> 00:06:15,170
So whenever you do an initialization?

100
00:06:15,190 --> 00:06:15,490
OK.

101
00:06:15,670 --> 00:06:19,510
So what happens is this is called the initialization list.

102
00:06:19,990 --> 00:06:20,290
OK.

103
00:06:21,220 --> 00:06:24,220
So in this list, we only defined the first element as zero.

104
00:06:24,550 --> 00:06:28,550
So whenever do do do you will do initialization of inherit?

105
00:06:28,930 --> 00:06:31,930
The remaining elements of the array would automatically becomes IDO.

106
00:06:31,960 --> 00:06:32,290
OK.

107
00:06:32,530 --> 00:06:34,180
So what would happen in the first case?

108
00:06:34,180 --> 00:06:40,360
If you render that, you will see that this contains some random data.

109
00:06:40,390 --> 00:06:42,890
So we call this random rate as garbage data, OK?

110
00:06:43,360 --> 00:06:45,100
We have not done initialization.

111
00:06:45,100 --> 00:06:48,190
If that is not initialized, it will contain garbage.

112
00:06:48,490 --> 00:06:49,890
What will happen in this case?

113
00:06:49,930 --> 00:06:52,600
So we have given three elements in the initialization list.

114
00:06:53,170 --> 00:06:59,920
So we would have three elements whose values are one two three and the remaining element would be zero

115
00:06:59,920 --> 00:07:00,790
automatically OK.

116
00:07:01,630 --> 00:07:04,040
And what would happen in this case in this?

117
00:07:04,060 --> 00:07:06,700
You can see we have not defined the size of the ADI.

118
00:07:06,730 --> 00:07:07,060
OK.

119
00:07:07,330 --> 00:07:13,690
So if you're given the initialization list, then defining the size is actually optional.

120
00:07:14,800 --> 00:07:21,940
And what you can do is you can you will have only area of size three in which we have three elements

121
00:07:22,240 --> 00:07:23,200
one two three, OK.

122
00:07:23,680 --> 00:07:28,300
So you can also have array of complex data type, such as a string.

123
00:07:28,390 --> 00:07:33,820
The string is a predefined data type, and string itself is an array of characters.

124
00:07:33,820 --> 00:07:37,720
OK, so you can see this is a linear add strings.

125
00:07:37,990 --> 00:07:38,320
OK.

126
00:07:38,560 --> 00:07:42,370
On each string is also an array, so it's kind of a two, really.

127
00:07:42,670 --> 00:07:45,370
So we will see this a little later on in this course.

128
00:07:45,670 --> 00:07:50,470
OK, so just I'm telling you, you can also create array of some complex data.

129
00:07:51,850 --> 00:07:53,540
So I hope this is clear.

130
00:07:53,560 --> 00:08:00,370
How do we create and edit a now in the next you to really do some coding and see how we can input output

131
00:08:00,370 --> 00:08:01,990
update and print entity?
