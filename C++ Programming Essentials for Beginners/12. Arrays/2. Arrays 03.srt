1
00:00:02,510 --> 00:00:07,850
Everyone in this lecture will talk about one important concept that you should don't when you're trying

2
00:00:07,850 --> 00:00:09,950
to pass at is two functions, okay?

3
00:00:10,340 --> 00:00:17,660
So let's discuss this concept and what are the intricate things that some people may miss while working

4
00:00:17,660 --> 00:00:19,310
with areas and functions?

5
00:00:19,640 --> 00:00:23,000
So let me create a new example and let me call it as they all do.

6
00:00:24,020 --> 00:00:29,810
And again, we will have Io's dream namespace.

7
00:00:31,020 --> 00:00:34,860
And what we will do maybe will create a simple function.

8
00:00:35,030 --> 00:00:39,510
OK, and we will create a simple function to print that.

9
00:00:39,700 --> 00:00:44,360
OK, let's call it as Braintree, and this function is going to accept the eddy.

10
00:00:45,680 --> 00:00:49,880
And it is also going to accept the number of elements of that.

11
00:00:50,020 --> 00:00:56,270
So why the number of elements that need it, I will tell you exactly why it is needed, the next excretory.

12
00:00:56,840 --> 00:01:01,250
And let's initialize it one two three four five six.

13
00:01:01,850 --> 00:01:05,240
And let's say this is the three.

14
00:01:05,760 --> 00:01:10,340
And here I have not given the size, so I'm going to compute the number of elements.

15
00:01:11,030 --> 00:01:15,830
These are very that means, oh, how much memory this is going to take.

16
00:01:15,840 --> 00:01:21,450
So this is going to take six and offered 24 bytes and each element is of their type.

17
00:01:21,470 --> 00:01:22,070
Indeed, it is.

18
00:01:22,070 --> 00:01:24,180
I'm going to divide it by size of eight.

19
00:01:26,180 --> 00:01:29,060
So this is one common practice you would often see.

20
00:01:29,390 --> 00:01:32,840
This will give us 24 divided by food that is six.

21
00:01:33,410 --> 00:01:35,870
We have six elements in this particular area.

22
00:01:36,320 --> 00:01:40,900
So what I'm doing, I'm computing how many elements I did in this particular.

23
00:01:40,970 --> 00:01:41,270
OK.

24
00:01:41,630 --> 00:01:47,150
Now one thing we are going to do is I'm going to print size of.

25
00:01:49,810 --> 00:01:52,030
Eddie, inside this particular mine.

26
00:01:52,150 --> 00:01:55,120
OK, so maybe I can say we are in Maine.

27
00:01:57,190 --> 00:01:57,670
And.

28
00:02:00,190 --> 00:02:01,790
Let us do the same statement.

29
00:02:01,810 --> 00:02:04,690
Let us run the same statement in the printed function, OK?

30
00:02:08,830 --> 00:02:09,190
Yes.

31
00:02:09,430 --> 00:02:15,730
So here what what you can see, we are getting a widening that size of very little on the size of all.

32
00:02:21,360 --> 00:02:24,810
This area, and I will tell you what this is going to be.

33
00:02:25,260 --> 00:02:31,260
So despite the warning, we are going to run the good because it's a warning, it's not a compilation

34
00:02:31,260 --> 00:02:31,530
at it.

35
00:02:32,040 --> 00:02:35,730
So what I'm going to show you, we are inside function.

36
00:02:38,020 --> 00:02:44,280
So despite the warning, we are going to run the code and let me assure you, this is the road to Eddie.

37
00:02:44,980 --> 00:02:46,180
And here we are.

38
00:02:46,180 --> 00:02:50,320
Getting inside mean on the size of that is 24, which is fine.

39
00:02:51,040 --> 00:02:54,400
We also should call this function, but integrity.

40
00:02:55,060 --> 00:02:59,200
And here we are saying get taken the city and Dallas.

41
00:03:00,390 --> 00:03:05,130
The size of the city, so now you can see inside mean the size is 24.

42
00:03:05,160 --> 00:03:07,230
Inside function, the size is eight.

43
00:03:07,820 --> 00:03:12,420
Now can you think of why this is happening, why this is happening?

44
00:03:13,020 --> 00:03:16,590
The reason is inside mean we actually have already.

45
00:03:16,620 --> 00:03:16,920
OK.

46
00:03:18,060 --> 00:03:23,250
So inside, man, we actually have our edit, but inside the function, we don't have it, we just have

47
00:03:23,250 --> 00:03:24,990
the address of daddy.

48
00:03:25,020 --> 00:03:27,720
OK, we only have the address.

49
00:03:29,770 --> 00:03:30,670
Of the Eddie.

50
00:03:32,360 --> 00:03:38,600
So these addresses are stored in the form of variables known as pointer variables, and these variables

51
00:03:38,600 --> 00:03:40,430
have a saves of eight bytes.

52
00:03:41,150 --> 00:03:45,410
And this edit will have a size of depending on how many elements we have.

53
00:03:45,440 --> 00:03:48,560
And this gives it a six undervote that is 24, right?

54
00:03:48,590 --> 00:03:48,860
OK.

55
00:03:49,460 --> 00:03:54,560
So one thing I want to tell you is if you do something like this, if you print that ahead, you can

56
00:03:54,560 --> 00:03:59,140
simply do four intake will do zero less than an A-plus plus.

57
00:03:59,930 --> 00:04:00,260
OK.

58
00:04:00,710 --> 00:04:04,550
And you're going to see out at very.

59
00:04:05,710 --> 00:04:06,800
So this is going to work.

60
00:04:07,300 --> 00:04:08,270
This will work fine.

61
00:04:08,290 --> 00:04:09,400
This we have already seen.

62
00:04:09,850 --> 00:04:13,210
We know and this six, this look will work fine.

63
00:04:13,720 --> 00:04:17,590
But if you do a similar thing here, if you do a similar thing, it.

64
00:04:18,770 --> 00:04:21,980
So if you try to bring this error here, OK?

65
00:04:23,250 --> 00:04:25,110
Let me show it to you.

66
00:04:29,830 --> 00:04:31,990
This will not work as expected.

67
00:04:32,530 --> 00:04:39,430
This will not work as expected, so we are printing this array inside me and we are also printing this

68
00:04:39,430 --> 00:04:40,510
ad inside a function.

69
00:04:41,850 --> 00:04:42,810
So let's.

70
00:04:44,940 --> 00:04:45,840
Try to run this.

71
00:04:47,450 --> 00:04:52,340
And you can see inside mean we are getting all the six elements inside function, we are just getting

72
00:04:52,340 --> 00:04:53,060
there two elements.

73
00:04:53,120 --> 00:04:57,230
The reason is we don't have the correct value of in here.

74
00:04:57,320 --> 00:05:01,620
We don't know what is the number of elements yet because what is happening is.

75
00:05:01,640 --> 00:05:10,430
Let me let me show you to what actually happened is when you created the city, this main has its own

76
00:05:10,430 --> 00:05:11,240
local memory.

77
00:05:11,700 --> 00:05:11,870
OK.

78
00:05:12,930 --> 00:05:20,100
And this function, Braintree, this also gets when it gets called, it also gets in, gets pushed in

79
00:05:20,100 --> 00:05:20,880
the call stack.

80
00:05:21,330 --> 00:05:23,280
And this is the function Braintree.

81
00:05:24,690 --> 00:05:33,210
So when you're passing this area here to here, OK, this does not happen by pass by value.

82
00:05:33,210 --> 00:05:35,150
This happens by pass by reference.

83
00:05:35,820 --> 00:05:39,720
OK, then instead of passing the area, you are actually passing the address.

84
00:05:40,170 --> 00:05:46,080
This variable is actually the address of that is and I mean, you actually have the eddy that is located.

85
00:05:46,560 --> 00:05:48,090
This size is 24 bytes.

86
00:05:48,570 --> 00:05:51,600
But when you're passing the city, you are related.

87
00:05:51,600 --> 00:05:52,710
This address is hundred.

88
00:05:53,310 --> 00:05:58,020
So you're only storing this address here and this box occupies eight bytes.

89
00:05:58,890 --> 00:06:01,980
Then you try to compute the value of in that the size of it.

90
00:06:02,270 --> 00:06:07,380
So here this area is only of decided bytes divided by size of and that is food.

91
00:06:07,780 --> 00:06:09,180
So you get this say this too.

92
00:06:09,780 --> 00:06:13,090
And here you get 24 divided were for that six.

93
00:06:13,800 --> 00:06:19,350
That is why this law works as expected and this will not work as expected.

94
00:06:19,350 --> 00:06:19,590
OK?

95
00:06:20,280 --> 00:06:22,820
So that's a mistake that we believe can do.

96
00:06:22,830 --> 00:06:28,350
So you should always remember when you're passing, it is two functions, then the user is advised by

97
00:06:28,810 --> 00:06:29,430
reference.

98
00:06:29,610 --> 00:06:36,100
That means only their addresses, bust and undefined you can make in their indexes to make it more explicit.

99
00:06:36,120 --> 00:06:37,320
You can use this diethood.

100
00:06:37,350 --> 00:06:39,560
That means it is a pointer variable.

101
00:06:39,570 --> 00:06:43,860
It's not a it's not that it's a pointer variable to both.

102
00:06:44,520 --> 00:06:47,460
The previous index on this index are same.

103
00:06:47,460 --> 00:06:52,120
You can either use this or you can use this manual by single error dual function.

104
00:06:52,140 --> 00:06:54,810
OK, so let's build our code.

105
00:06:55,560 --> 00:07:00,840
And let me show you again that this works in a similar manner.

106
00:07:01,470 --> 00:07:08,160
And what may happen is now you want to actually print that inside the function to what you should do

107
00:07:08,160 --> 00:07:11,820
is instead of computing the value of ended.

108
00:07:12,120 --> 00:07:12,420
OK.

109
00:07:12,750 --> 00:07:20,250
What you should do, you should accept the value of N as an input from Maine because Maine knows what

110
00:07:20,250 --> 00:07:22,050
is the correct size of the eddy.

111
00:07:22,410 --> 00:07:23,550
So you should pass.

112
00:07:23,550 --> 00:07:31,520
And here and now and the code you will see both mean and the function that giving us the correct output,

113
00:07:31,530 --> 00:07:31,800
OK?

114
00:07:32,820 --> 00:07:40,030
So one more thing we can do is maybe I can say let me update area of zero equals, let's 100.

115
00:07:41,280 --> 00:07:44,190
And now what I will do, I'll first call this function.

116
00:07:45,880 --> 00:07:51,520
And then I will print inside mine, OK, then I will print inside me, so I've changed the order.

117
00:07:52,570 --> 00:07:56,830
Now what we can see is we are updating the zero element inside this function.

118
00:07:57,280 --> 00:08:04,810
And since it is biased by friends there, it is expected that the value of any or zero should change

119
00:08:04,810 --> 00:08:05,230
in both.

120
00:08:05,350 --> 00:08:05,680
OK.

121
00:08:06,080 --> 00:08:13,240
So you can see area of zero is now changed, both inside the function and inside mine as well.

122
00:08:13,240 --> 00:08:16,780
That means both of them are sharing a common memory.

123
00:08:17,140 --> 00:08:19,360
Border areas are same.

124
00:08:19,810 --> 00:08:21,850
They have a common memory location.

125
00:08:21,860 --> 00:08:23,050
They are not different.

126
00:08:23,470 --> 00:08:27,610
This also confirms the fact that it is a robust way different.

127
00:08:27,980 --> 00:08:29,740
I hope you understood this concept.

128
00:08:30,280 --> 00:08:31,690
Let us meet in the next lecture.
