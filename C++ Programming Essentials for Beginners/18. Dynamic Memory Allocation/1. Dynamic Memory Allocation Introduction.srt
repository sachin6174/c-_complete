1
00:00:01,990 --> 00:00:07,900
Everyone in this lecture, I'm going to talk about a very special topic, which is known as dynamic

2
00:00:08,680 --> 00:00:10,060
memory allocation.

3
00:00:10,270 --> 00:00:14,530
OK, so what is this meaning of dynamic memory allocation?

4
00:00:14,620 --> 00:00:15,460
We will discuss.

5
00:00:16,180 --> 00:00:17,770
And what is the dynamic memory?

6
00:00:17,770 --> 00:00:21,370
That is something that we are all doing to discuss and how we can look at it.

7
00:00:21,610 --> 00:00:23,470
Obviously, we will look at the term index.

8
00:00:24,310 --> 00:00:29,980
So what happens is when you create a relationship, you generally do it something like this.

9
00:00:31,060 --> 00:00:33,300
So you define a constraint, either.

10
00:00:33,940 --> 00:00:40,010
OK, this is a content site, and whenever you do this, the memory is allocated.

11
00:00:40,060 --> 00:00:43,450
For example, later, this is a function in which you are creating this, Eddie.

12
00:00:44,320 --> 00:00:46,900
So this function when it is called.

13
00:00:47,940 --> 00:00:51,630
It occupies some space in this documentary.

14
00:00:52,230 --> 00:00:58,290
The start is a type of memory that is available on all your local variables, let's say, and B and

15
00:00:58,290 --> 00:01:04,600
C, all these variables will occupy some part in this back memory.

16
00:01:04,730 --> 00:01:07,050
OK, so this is a this is like to be in.

17
00:01:07,050 --> 00:01:07,920
This is like to see.

18
00:01:09,010 --> 00:01:13,000
And whenever this function call is over, let's say you heard the written statement.

19
00:01:13,330 --> 00:01:15,070
All these memories destroyed, OK?

20
00:01:15,670 --> 00:01:20,650
So this content is memory that resides on the call stack.

21
00:01:21,340 --> 00:01:23,410
This is known as starting memory.

22
00:01:23,830 --> 00:01:24,090
OK.

23
00:01:25,130 --> 00:01:25,790
And.

24
00:01:27,410 --> 00:01:29,390
This is allocated by the pilot.

25
00:01:30,710 --> 00:01:31,010
OK.

26
00:01:31,520 --> 00:01:35,540
That means when this function is called, this memory is allocated by the compiler.

27
00:01:35,960 --> 00:01:41,060
And when this function is gone, this memory is also destroyed by the compiler.

28
00:01:41,060 --> 00:01:45,200
OK, so it's created and destroyed by the compiler.

29
00:01:45,530 --> 00:01:47,930
So this is what happened with the static memory.

30
00:01:48,620 --> 00:01:53,060
But in certain cases, we may need to work with dynamic memory.

31
00:01:53,510 --> 00:01:53,810
OK.

32
00:01:54,500 --> 00:01:56,000
What is dynamic memory?

33
00:01:56,570 --> 00:01:59,630
It's a memory that is not allocated by the compiler.

34
00:01:59,630 --> 00:02:03,620
Does memory that is allocated during runtime, for example.

35
00:02:03,980 --> 00:02:07,160
You ask the user, OK, what is the value of n tell me?

36
00:02:07,730 --> 00:02:14,510
And I will create a dynamic area of say then only when this value of and is given as inputs of what

37
00:02:14,510 --> 00:02:15,410
we will do will talk.

38
00:02:15,830 --> 00:02:21,210
It'll create a tree like this in stuttery equals new end.

39
00:02:21,530 --> 00:02:26,240
And so basically the programming has to use a keyword called meal.

40
00:02:26,570 --> 00:02:32,270
That means we're allocating new memory at runtime and it is going to contain and integers.

41
00:02:32,300 --> 00:02:35,120
So this is the syntax of dynamic memory allocation.

42
00:02:35,180 --> 00:02:38,450
So let me just try to explain you what is going to happen.

43
00:02:39,450 --> 00:02:41,570
What we have done and stored.

44
00:02:42,060 --> 00:02:46,260
Yeah, if you look at this index, this is actually a pointer variable.

45
00:02:46,280 --> 00:02:56,440
That means it can store some address and you're making this equal to some of memory address or gets

46
00:02:56,450 --> 00:02:59,840
a new and let's say some and.

47
00:03:01,390 --> 00:03:06,040
OK, now this can be considered this can be a variable that is taken as input.

48
00:03:06,400 --> 00:03:09,640
Now what happened is this memory is not allocated on the stock.

49
00:03:09,640 --> 00:03:15,030
For example, let's say you are doing this inside of function call and you need something like this.

50
00:03:15,070 --> 00:03:17,680
So what will what is going to happen when this function is called?

51
00:03:17,680 --> 00:03:19,720
It will occupy some memory in the call stack.

52
00:03:20,410 --> 00:03:21,810
This variable instead.

53
00:03:22,450 --> 00:03:24,490
OK, so it is a static pointer variable.

54
00:03:24,580 --> 00:03:29,010
It is statically allocated, so it will be a part of the call stack.

55
00:03:29,010 --> 00:03:30,730
OK and start at.

56
00:03:31,510 --> 00:03:38,380
But when you use this word new and this new is used for allocating memory on renting.

57
00:03:38,770 --> 00:03:43,720
So this memory goes inside a part of a system memory known as the heap memory.

58
00:03:44,080 --> 00:03:44,380
OK.

59
00:03:44,860 --> 00:03:49,940
Generally, this heap memory is a large area inside the system.

60
00:03:49,970 --> 00:03:57,340
Let's say this is a heap memory, and in this heap we are looking to the Eddie, which does not have

61
00:03:57,340 --> 00:03:59,800
any name, but it does have some address.

62
00:03:59,830 --> 00:04:00,010
OK.

63
00:04:00,230 --> 00:04:02,890
Maybe this addresses letter two zero zero eight.

64
00:04:04,580 --> 00:04:10,870
What is going to happen is this Eddy is going to point to this heap memory, OK?

65
00:04:11,410 --> 00:04:15,160
And once this function call is or what, what is going to happen?

66
00:04:15,880 --> 00:04:23,110
This call stack will be destroyed, but this memory will remain as it is because it is dynamically allocated.

67
00:04:23,260 --> 00:04:26,950
It will stay until the programmer does not free it up.

68
00:04:27,310 --> 00:04:34,780
OK, so it's the job of the programmer to delete and create this dynamic memory.

69
00:04:35,650 --> 00:04:40,810
The compiler will not delete this memory, even if the function call in which this memory is created

70
00:04:41,290 --> 00:04:41,650
is.

71
00:04:42,980 --> 00:04:48,860
Over this issue, zero zero, it is going to get stored here.

72
00:04:49,070 --> 00:04:52,830
So this is the gray box and two zero zero eight will get copied it.

73
00:04:53,340 --> 00:04:58,430
We are actually putting our address in the printer variable and this is how the things are going to

74
00:04:58,430 --> 00:05:00,860
work now if you use area of two.

75
00:05:01,610 --> 00:05:06,110
This is actually converted into start off error plus.

76
00:05:07,180 --> 00:05:14,510
So this is an that is based address error plus one is this address error plus two this address.

77
00:05:15,260 --> 00:05:17,240
These two statements are actually equal.

78
00:05:17,540 --> 00:05:23,390
OK, so we are actually going to an address and we are going to reference that second location.

79
00:05:23,810 --> 00:05:27,650
So when I talk about, OK, how do you update the variable inside this memory?

80
00:05:27,660 --> 00:05:28,820
Maybe I want to put this value.

81
00:05:28,820 --> 00:05:29,180
Five.

82
00:05:29,630 --> 00:05:32,630
You can simply write error of two equals five.

83
00:05:33,020 --> 00:05:36,050
That means any for this index would remain similar.

84
00:05:36,140 --> 00:05:43,430
It will not change because this gets broken down by the compiler into an instruction which looks like

85
00:05:43,430 --> 00:05:43,820
this.

86
00:05:44,810 --> 00:05:45,110
OK.

87
00:05:45,750 --> 00:05:49,280
And yeah, so this is about dynamic memory.

88
00:05:49,610 --> 00:05:53,990
Now, one thing I want to talk about is how you can delete this memory.

89
00:05:53,990 --> 00:05:57,300
OK, now it's about your work is done and you don't want this.

90
00:05:57,620 --> 00:06:02,660
So at the end of the function, what you can do, you can say, OK, I want to delete.

91
00:06:04,130 --> 00:06:05,330
This particular area.

92
00:06:06,980 --> 00:06:12,350
And this is going to delay the say, OK, so we are going to use new word, allocate the memory.

93
00:06:12,590 --> 00:06:15,800
OK, we'll just explain you again in story.

94
00:06:16,160 --> 00:06:19,370
This is equal to new and of and.

95
00:06:20,440 --> 00:06:20,770
OK.

96
00:06:21,370 --> 00:06:28,210
And if I want to put some value against the area of I equals some value, this is how I can update.

97
00:06:29,020 --> 00:06:29,350
OK?

98
00:06:29,830 --> 00:06:34,040
And maybe after some lines of code, you don't want this area.

99
00:06:34,060 --> 00:06:36,130
You can also see this space.

100
00:06:37,440 --> 00:06:41,180
You can delete, followed by square records, followed by a look.

101
00:06:41,620 --> 00:06:48,600
The generators used for creating dynamic areas, but then maybe some real use case may involve.

102
00:06:49,590 --> 00:06:52,160
OK, let's let's get into dynamic candidate.

103
00:06:52,190 --> 00:06:56,790
So in that case, you're going to install X equals new.

104
00:06:58,350 --> 00:07:04,980
So what it is doing, we have a stark memory, we have a stark memory in that we are creating a variable

105
00:07:04,980 --> 00:07:06,450
called as Einstein X.

106
00:07:08,410 --> 00:07:09,550
And this is during the.

107
00:07:11,880 --> 00:07:16,920
During the address of another endangered variable that is there on the heap memory and suppose I want

108
00:07:16,920 --> 00:07:21,180
to put a value on it, I can simply say it's of X equals 10.

109
00:07:21,870 --> 00:07:25,470
This value is going to become a golden and later this is a b c.

110
00:07:25,470 --> 00:07:27,680
So this value would be a b c OK.

111
00:07:27,970 --> 00:07:30,690
But generally it would be a very maybe off, let's say.

112
00:07:31,920 --> 00:07:39,030
So I wondered then this would become a complete array like this and sort of excluded basically means

113
00:07:39,540 --> 00:07:41,250
X of zero is equal to 10.

114
00:07:41,400 --> 00:07:45,210
OK, so we are going to put this thing OK.

115
00:07:45,210 --> 00:07:51,240
So this is equivalent to saying star of X plus zero equal to 10 and with just nothing but sort of x

116
00:07:51,240 --> 00:07:51,900
equal to 10.

117
00:07:53,070 --> 00:07:55,300
So this is how it's going to work.

118
00:07:55,500 --> 00:07:58,590
Maybe I want to put something yet again to x of one equal to 20.

119
00:07:58,890 --> 00:07:59,940
This would put 20.

120
00:08:00,630 --> 00:08:01,950
I hope this is clear.

121
00:08:01,980 --> 00:08:08,880
And if you want to delete this array so you can delete as the keyword that frees up their dynamic memory

122
00:08:09,690 --> 00:08:12,350
and followed by square brackets if it is any.

123
00:08:13,440 --> 00:08:14,810
And followed by the name of Daddy.

124
00:08:14,940 --> 00:08:15,450
That's it.

125
00:08:15,660 --> 00:08:17,370
It is going to delete this memory.

126
00:08:18,300 --> 00:08:20,670
Now this memory will not get deleted.

127
00:08:21,040 --> 00:08:22,470
Elder function call is not over.

128
00:08:22,470 --> 00:08:23,130
OK, so this.

129
00:08:24,350 --> 00:08:28,970
This is in the hand of compiler, and this is in the hand of programmers.

130
00:08:29,180 --> 00:08:29,450
OK.

131
00:08:30,490 --> 00:08:39,250
So generally, this memory you can allocate on their own time and you have to free this up.

132
00:08:39,740 --> 00:08:45,880
The compiler does not delete this memory, even if the function calls over and after the program is

133
00:08:45,880 --> 00:08:50,920
finished executing, all the memories are destroyed, OK, because everything is a part of the program

134
00:08:51,280 --> 00:08:51,730
memory.

135
00:08:52,210 --> 00:08:56,740
But during the execution, if you want to free this up, you should use this delete upgrade.

136
00:08:56,890 --> 00:09:02,770
If you don't use it and you don't need that particular area or, for example, you lose the address

137
00:09:02,770 --> 00:09:04,580
of this, Eddie.

138
00:09:05,320 --> 00:09:08,380
And you don't you forget to use this delete statement.

139
00:09:08,380 --> 00:09:12,100
In that case, a condition arises which we call as a memory leak.

140
00:09:12,280 --> 00:09:18,520
That means we have wasted some part of the memory which we are not using, and we don't have the address

141
00:09:18,520 --> 00:09:21,490
to reach that particular memory.

142
00:09:21,790 --> 00:09:24,130
Let me show you an example of memory leak.

143
00:09:24,820 --> 00:09:27,220
Let us see an example of memory leak.

144
00:09:27,760 --> 00:09:31,120
For example, you have a function on that function.

145
00:09:31,120 --> 00:09:34,870
You say OK in Star X equals some.

146
00:09:36,420 --> 00:09:43,650
Eddie, in New Zealand, you followed by 100 and then you do some work, maybe you do X or Y equals

147
00:09:43,650 --> 00:09:50,280
two X or Y a minus one plus two for all values off.

148
00:09:50,520 --> 00:09:52,050
I agree that an equal to one.

149
00:09:52,110 --> 00:09:53,700
Maybe you better look kind of us stuff.

150
00:09:54,330 --> 00:09:57,000
And later on, you're done some x thing.

151
00:09:57,130 --> 00:09:59,760
OK, you said it done the last well of this.

152
00:10:00,600 --> 00:10:05,670
What is going to happen is when you call this function, it's going to create a dynamic memory.

153
00:10:06,780 --> 00:10:11,460
And when this function call is over, this X is gone.

154
00:10:11,710 --> 00:10:18,420
You know, this addresses when to get lost and you have not returned and deleted treatment, any of

155
00:10:18,420 --> 00:10:18,560
it.

156
00:10:19,020 --> 00:10:21,810
And now there is no point at which is pointing to this memory.

157
00:10:21,810 --> 00:10:27,240
So that means we have already wasted this memory and this is going to cause a memory leak.

158
00:10:28,890 --> 00:10:32,790
So when you're writing code, you should try to avoid memory leaks.

159
00:10:33,210 --> 00:10:39,960
And in many applications which run our servers, if you start creating memory leaks, then your server

160
00:10:39,960 --> 00:10:46,260
will get full at a certain point and it will stop working normally.

161
00:10:46,260 --> 00:10:52,200
OK, you will get some errors, memories for or you may not be executed or other programs on your server.

162
00:10:52,260 --> 00:10:52,530
OK.

163
00:10:52,880 --> 00:10:53,850
It's a critical thing.

164
00:10:53,970 --> 00:10:58,410
You should handle memory leaks in your code, and that's all for this lecture.
