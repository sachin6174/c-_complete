1
00:00:01,070 --> 00:00:06,710
I assume now we will discuss to write the pseudocode for the D3D problem, so given the numbers like

2
00:00:06,710 --> 00:00:10,460
in me, we want to find out the D3D of the numbers, OK?

3
00:00:11,000 --> 00:00:14,970
So for example, then British 18:20, we discussed the distasteful.

4
00:00:15,620 --> 00:00:22,340
Another thing that we discussed in order to find that easily, we will iterate from one to the minimum

5
00:00:22,340 --> 00:00:28,490
of the two numbers and we because the DCD can never be greater than the smaller number.

6
00:00:28,520 --> 00:00:28,820
OK.

7
00:00:29,480 --> 00:00:34,610
What we want to do while iterating over this range, we want to find the largest number.

8
00:00:35,740 --> 00:00:37,690
That divides more than me.

9
00:00:38,170 --> 00:00:43,720
OK, so this we will implement using all the words, so first of all, we will read the numbers in B,

10
00:00:44,590 --> 00:00:50,140
and in order to iterate over this range, we will keep a bucket I that will store it on what value we

11
00:00:50,140 --> 00:00:50,890
currently are.

12
00:00:50,930 --> 00:00:54,370
So in the beginning, we get to this one and begin to give.

13
00:00:54,380 --> 00:01:02,290
While this eye is less than equal to minimum of a comma, B will do some work.

14
00:01:02,680 --> 00:01:02,950
OK.

15
00:01:03,430 --> 00:01:13,960
So what we will do will take that visibility, so we'll check if it is divisible by and B is also divisible

16
00:01:13,960 --> 00:01:14,820
by two.

17
00:01:14,830 --> 00:01:20,050
In both of these cases, after dividing with, the remainder should be zero.

18
00:01:21,190 --> 00:01:21,400
OK.

19
00:01:22,000 --> 00:01:30,040
So if if both of these conditions are true, then what we can do we can look at if two divides both

20
00:01:31,750 --> 00:01:38,320
20, then averages it is two, then we go to three, then we go to four and we do this thing for every

21
00:01:38,320 --> 00:01:38,770
location.

22
00:01:38,770 --> 00:01:41,380
To these Oakajee three equals two I.

23
00:01:42,160 --> 00:01:45,130
Otherwise, what we can do, otherwise we can see.

24
00:01:47,330 --> 00:01:53,140
If you, irrespective of this condition, is true or false, we will always try the next numbers will

25
00:01:53,150 --> 00:01:55,480
to equals two plus one.

26
00:01:55,850 --> 00:01:56,360
That's it.

27
00:01:56,750 --> 00:01:58,820
I will complete the loop.

28
00:01:59,270 --> 00:02:05,240
And now when we are out of the loop, we can print the value of DVD and begin to exit.

29
00:02:05,270 --> 00:02:05,510
OK.

30
00:02:06,440 --> 00:02:09,260
So this is how we'll compute digitally.

31
00:02:09,900 --> 00:02:14,390
And you may ask not what happens if that is.

32
00:02:15,510 --> 00:02:16,530
No, these you do, OK.

33
00:02:16,620 --> 00:02:22,940
So in the worst case, if there is no device, either one would be at least one is the one.

34
00:02:22,950 --> 00:02:27,360
One always divides two numbers and be OK if we ordinarily would be there to one.

35
00:02:27,370 --> 00:02:31,320
For example, if you have seven and eight, you want to find easily.

36
00:02:32,190 --> 00:02:36,410
So one divides a one two vote, seven and one divides B.

37
00:02:37,110 --> 00:02:38,140
This really would be one.

38
00:02:38,160 --> 00:02:42,120
And finally, if you print the DCT, the value of the city would be one.

39
00:02:42,960 --> 00:02:45,360
So I hope you have understood this algorithm.

40
00:02:45,360 --> 00:02:48,150
So we have exactly implemented what we discussed, OK?

41
00:02:49,130 --> 00:02:56,270
So given the numbers like 1822, what we are doing, we are going from equal to one two three four up

42
00:02:56,270 --> 00:03:02,630
to up to up to eight, and we are checking whether one divides.

43
00:03:02,630 --> 00:03:05,450
But yes, then one is the decision to divide us.

44
00:03:05,450 --> 00:03:07,040
But then do is that easily?

45
00:03:07,760 --> 00:03:13,490
Who does not divide it nor object to the three fold divide would then vote is the decision.

46
00:03:14,510 --> 00:03:17,360
And this continues on till the minimum value.

47
00:03:17,930 --> 00:03:22,070
So finally, this is the value of the city that you will get the largest one.

48
00:03:23,090 --> 00:03:26,300
So I hope you have understood this algorithm and that's all for this.

49
00:03:26,300 --> 00:03:26,690
We you.
