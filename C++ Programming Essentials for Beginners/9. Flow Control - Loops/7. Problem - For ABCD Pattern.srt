1
00:00:00,650 --> 00:00:04,050
Everyone in this lecture we're going to solve in a department problem.

2
00:00:04,070 --> 00:00:05,960
So let us look, what do we want to do?

3
00:00:06,510 --> 00:00:11,400
So we are given away love and and we want to print a button which looks like this.

4
00:00:11,420 --> 00:00:13,970
OK, let us try to break down this burden.

5
00:00:13,970 --> 00:00:18,350
So if we have any faith, so clearly we have five rows, one two.

6
00:00:21,270 --> 00:00:22,860
Three, four and five.

7
00:00:23,430 --> 00:00:29,280
And what you can observe in each rule, like in the first rule, what we have, we have five letters

8
00:00:29,280 --> 00:00:34,200
which are in the increasing order and then we have five letters which are in the decreasing order.

9
00:00:34,200 --> 00:00:38,160
So effectively I have n minus.

10
00:00:41,360 --> 00:00:43,430
I have n minus I plus one.

11
00:00:43,460 --> 00:00:46,010
OK, so these many letters, they are in the increasing order.

12
00:00:46,430 --> 00:00:49,160
And these many letters, they're also in the decreasing order rate.

13
00:00:49,700 --> 00:00:51,490
And every letter starts from me.

14
00:00:51,530 --> 00:00:54,320
So for the second row, we have like four letters.

15
00:00:55,130 --> 00:01:01,880
So if I try to put this formula that is five minus two plus one, it gives me Yogev four letters which

16
00:01:01,880 --> 00:01:06,050
are in the increasing order and then four letters which are in the decreasing order rate.

17
00:01:06,920 --> 00:01:10,820
And then then the same thing is happening for the third row three letters.

18
00:01:11,090 --> 00:01:13,880
Then two letters and then one letter, OK.

19
00:01:14,090 --> 00:01:18,950
So for the fifth third would be end minus and is five minus one plus.

20
00:01:19,820 --> 00:01:21,890
So five minus five plus one.

21
00:01:22,460 --> 00:01:27,230
So it would be one letter in the increasing order and one letter in the decreasing order.

22
00:01:27,800 --> 00:01:31,250
So we have we do have some observations, OK?

23
00:01:31,700 --> 00:01:34,310
And how do they generate letters in the increasing order?

24
00:01:34,310 --> 00:01:39,260
So I know that with each letter, there is a ASCII value that is marked.

25
00:01:39,350 --> 00:01:46,970
So if I want to go from A to B, I can do simply if my bucket is storing the letter E right, which

26
00:01:46,970 --> 00:01:49,640
internally is getting stored as the number sixty five.

27
00:01:50,060 --> 00:01:57,980
So if I increment this by adding one to a plus one will give me 66, which gets mobbed to the letter

28
00:01:57,980 --> 00:01:58,350
B right.

29
00:01:59,030 --> 00:02:03,770
We will play with data types in this problem as we write code right.

30
00:02:04,160 --> 00:02:06,310
So first of all, let us do one thing.

31
00:02:06,320 --> 00:02:13,700
Let us first write the code and we will try to break it down side by side, right?

32
00:02:13,730 --> 00:02:18,020
So I'll just copy this sample input and now we are in the code editor.

33
00:02:18,470 --> 00:02:22,670
This is what we want to achieve for and equal to five.

34
00:02:23,330 --> 00:02:31,730
So let me read the good hygiene include ice stream using namespace SD int main.

35
00:02:33,340 --> 00:02:35,410
And let's save this file as well right

36
00:02:40,240 --> 00:02:40,650
now.

37
00:02:40,780 --> 00:02:44,440
What I want to do, I want to create a budget and I want to read it.

38
00:02:44,890 --> 00:02:48,880
And then what I need to do to I need to iterate over Andrew.

39
00:02:49,030 --> 00:02:55,930
I have to do some work for any number of rules so I can start from one I can go to and or you can start

40
00:02:55,930 --> 00:02:59,320
from zero, you can go to and minus one that is all to OK.

41
00:03:00,220 --> 00:03:07,270
Now in every rule, we have to print the letters in the increasing order, or we have to print and minus

42
00:03:07,270 --> 00:03:12,280
I +1 letters in increasing order of values.

43
00:03:12,970 --> 00:03:23,400
And similarly, we have to print letters and minus I +1 letters in decreasing values.

44
00:03:23,410 --> 00:03:27,360
OK, so now what is the first value that we have in every row?

45
00:03:27,490 --> 00:03:34,480
So in every row, the value starts from the letter, so I can say God letter that is always eight on

46
00:03:34,480 --> 00:03:34,990
every two.

47
00:03:34,990 --> 00:03:38,560
So remember, I'm doing this initialization inside this loop.

48
00:03:38,560 --> 00:03:43,400
I am not doing it outside because I need this eight at the start of every door.

49
00:03:43,450 --> 00:03:46,150
And this is the point where this rule is getting started.

50
00:03:46,990 --> 00:03:49,480
So what I will do, I maybe make a count.

51
00:03:49,570 --> 00:03:55,380
So it count equal to one count less than equal to and minus eight plus one count plus.

52
00:03:56,020 --> 00:03:57,880
So what do I need to print?

53
00:03:57,880 --> 00:04:04,870
I need to print the letter and for the next iteration, I need to increase its value so I can do later

54
00:04:04,870 --> 00:04:09,250
equals letter plus one, or I can do letter plus plus.

55
00:04:09,460 --> 00:04:15,220
It will automatically see when you write letter guards the edge.

56
00:04:15,340 --> 00:04:18,310
This is equal to eight eight or letter equal to eight.

57
00:04:18,640 --> 00:04:22,840
If you don't see it plus one, it actually gives you the number six to six to eight.

58
00:04:23,200 --> 00:04:26,020
If you try to print as it will, you can observe.

59
00:04:26,350 --> 00:04:32,750
But if you just see it equals C-H plus one, right, I'm doing this correct problems in Digital Edition.

60
00:04:32,800 --> 00:04:36,280
This actually results in an integer like we have seen here.

61
00:04:36,610 --> 00:04:44,530
But when you store this in inside a bucket, which is of the type gathered and when you try to access

62
00:04:44,530 --> 00:04:50,380
that bucket for printing, it is going to print that in in the correct representation.

63
00:04:50,380 --> 00:04:51,820
OK, it's not going to give you an integer.

64
00:04:51,820 --> 00:04:53,890
So we are doing letter equals letter placement.

65
00:04:53,980 --> 00:04:59,770
This is the same as doing letter equal relatedness, and we are going to the next little for printing.

66
00:05:00,070 --> 00:05:00,370
OK.

67
00:05:00,760 --> 00:05:03,320
Now one thing that is going to happen.

68
00:05:03,340 --> 00:05:11,320
So suppose we are in the second row and what we did, we said, OK, we'll print D and we'll do later

69
00:05:11,320 --> 00:05:13,840
plus plus, which makes this letter as B.

70
00:05:14,080 --> 00:05:20,020
So we print being the next iteration, we make this as C in the next iteration, we print C and we do

71
00:05:20,020 --> 00:05:22,300
letter plus plus, which makes it as D.

72
00:05:23,080 --> 00:05:29,170
And in the next iteration, we print the letter, which is D, and we make this letter as a unit.

73
00:05:30,210 --> 00:05:32,170
Now what do you want next?

74
00:05:32,260 --> 00:05:36,400
So you want to print a and you again want to start from the right.

75
00:05:36,550 --> 00:05:40,420
You again want to start from within this jump.

76
00:05:40,740 --> 00:05:43,830
How do I get a d from the letter right?

77
00:05:44,290 --> 00:05:47,080
That means we have to take one step backwards.

78
00:05:47,500 --> 00:05:52,540
So now if you come out of this loop or if you see what would be the final value of letter when you come

79
00:05:52,540 --> 00:05:57,910
out of the loop, so it would be one value more than what you have last printed.

80
00:05:57,910 --> 00:05:59,200
So what is the last printed?

81
00:05:59,440 --> 00:06:02,910
So you have printed B, So what is the next that you want to print?

82
00:06:02,920 --> 00:06:09,850
It is all 2D, so you have to take one step back and you have to say, OK, it letter equal to letter

83
00:06:09,850 --> 00:06:10,540
minus one.

84
00:06:11,200 --> 00:06:17,770
Basically, you're kind of resetting the value to the previous printed letter.

85
00:06:18,130 --> 00:06:22,300
So you are going from E back to the D, and this is true for every row.

86
00:06:23,020 --> 00:06:29,020
So now I can tell I again want to print and minus one letters, but now in the decreasing order, so

87
00:06:29,020 --> 00:06:35,230
I can t count equal to one count less than equal to and minus I placed one count plus plus.

88
00:06:35,470 --> 00:06:37,450
So count will still still remains m.

89
00:06:37,450 --> 00:06:40,900
So we are saying OK, if we want to print four letters then we are losing.

90
00:06:40,900 --> 00:06:42,130
We want to print four letters.

91
00:06:42,130 --> 00:06:48,940
OK, so now what those letters would be, they would start from B and they would go in a decreasing

92
00:06:48,940 --> 00:06:50,410
order of printing.

93
00:06:50,410 --> 00:06:56,050
So I will see out later and Al and I can select a minus minus.

94
00:06:56,050 --> 00:06:58,990
That's it to the count is getting increased.

95
00:06:59,440 --> 00:07:03,670
And finally, when your completed, do we have to go to new line?

96
00:07:03,820 --> 00:07:09,490
So we'll see out and so actually and is not required at these places.

97
00:07:10,210 --> 00:07:13,700
So I will remove it and I will give Andal here.

98
00:07:13,720 --> 00:07:18,310
OK, now let us try to build this code and let's try to run it.

99
00:07:19,780 --> 00:07:23,470
We do have an error because of this statement.

100
00:07:24,880 --> 00:07:29,470
So let's just command this thing out, and now it is building fine.

101
00:07:30,530 --> 00:07:33,080
And maybe I can show you in the demo as well.

102
00:07:33,650 --> 00:07:35,180
So dodge large for.

103
00:07:37,360 --> 00:07:38,200
Rector, pardon.

104
00:07:38,650 --> 00:07:39,670
Maybe five.

105
00:07:40,510 --> 00:07:45,400
All, so I'm getting this burden that looks absolutely correct.

106
00:07:45,580 --> 00:07:51,580
So this is what we wanted to do in this example, and I hope now you have understood what we are doing,

107
00:07:51,580 --> 00:07:54,580
so we have this loop of rules, OK?

108
00:07:55,120 --> 00:07:58,210
And for every rule, we have letters in the increasing order.

109
00:07:58,840 --> 00:08:01,210
And we also have letters in the decreasing order.

110
00:08:01,780 --> 00:08:07,810
But to initialize the value from where we should start printing letters in a decreasing order.

111
00:08:08,290 --> 00:08:15,100
This particular statement is needed and this statement simply initialize the start later as a forever.

112
00:08:15,250 --> 00:08:15,550
OK.

113
00:08:16,070 --> 00:08:18,190
And this new line you're already familiar with.

114
00:08:18,610 --> 00:08:22,390
So this I hope this breakdown is clear, and that's all for this video.
