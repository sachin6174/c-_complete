1
00:00:01,070 --> 00:00:06,560
Everyone's in this lecture will see how you can count, but count the number of segments in a particular

2
00:00:06,560 --> 00:00:07,070
number.

3
00:00:08,980 --> 00:00:13,660
So what I said, but said Brits are those Brits, which are one, for example, if I give you the number

4
00:00:13,690 --> 00:00:20,080
nine, which is like one zero zero one, then I can say it has doubled, which are said words.

5
00:00:21,100 --> 00:00:26,260
I want to count the number of red bits in the binary representation of any number.

6
00:00:26,300 --> 00:00:27,850
That's what we need to know.

7
00:00:29,290 --> 00:00:34,060
So let us see how we can approach this particular problem of accounting standards.

8
00:00:34,720 --> 00:00:37,930
So let us discuss the approach.

9
00:00:38,620 --> 00:00:40,380
So it's pretty easy.

10
00:00:40,390 --> 00:00:46,330
So we know the number is stored like this and we also know how we can find out the last bit so we can

11
00:00:46,330 --> 00:00:47,620
do around with one.

12
00:00:48,190 --> 00:00:51,400
And this will tell us what is the last bit we will get to know?

13
00:00:51,400 --> 00:00:52,270
Get this with this one.

14
00:00:53,080 --> 00:00:57,690
And for the next iteration, what we can do, we can remove this bit by doing the right shift.

15
00:00:57,710 --> 00:01:01,000
Okay, so we can see the last bit does an end one.

16
00:01:01,540 --> 00:01:05,170
And if this is one, then I will increment the count of my side.

17
00:01:05,170 --> 00:01:11,250
But if it is zero, I will not increment the count OK, or I can simply rate let's initial count zero,

18
00:01:11,260 --> 00:01:13,360
then then again, to count plus equals two and one.

19
00:01:14,170 --> 00:01:15,070
The last word is one.

20
00:01:15,220 --> 00:01:17,890
Then count will increment by one of the last four to zero.

21
00:01:17,890 --> 00:01:19,330
The count will increment by zero.

22
00:01:19,900 --> 00:01:24,640
And I want to remove this so I can to any Puerto Nightshift one.

23
00:01:25,660 --> 00:01:29,740
The next time you will get one and zero, it will be zero count will change by zero.

24
00:01:30,280 --> 00:01:34,660
Next time it would be you remove this one, zero and one, it would be still zero.

25
00:01:34,690 --> 00:01:35,920
So count will change with zero.

26
00:01:36,310 --> 00:01:41,440
Next time you remove this one and run it as one two count will increment by one final count would be

27
00:01:41,440 --> 00:01:41,710
two.

28
00:01:42,650 --> 00:01:44,530
OK, so this is what we can do.

29
00:01:44,530 --> 00:01:51,700
So I can write the function count because I get the numbering and there I can see why and is greater

30
00:01:51,700 --> 00:01:52,270
than zero.

31
00:01:52,360 --> 00:01:59,110
What I can do every time find out the last bit like in the end, last bit.

32
00:01:59,740 --> 00:02:03,520
I don't know when we begin to count that to zero.

33
00:02:03,850 --> 00:02:06,280
And here I can find out the last bit.

34
00:02:06,700 --> 00:02:13,240
So last, but there's nothing word and one, and I can say count plus equals to last bit.

35
00:02:13,550 --> 00:02:15,100
OK, if it is, one count will change.

36
00:02:15,100 --> 00:02:17,230
One one zero count will not change.

37
00:02:18,010 --> 00:02:22,270
And then we can do as an equal and right shift one.

38
00:02:22,420 --> 00:02:24,730
And from here, we can read and count.

39
00:02:26,030 --> 00:02:34,980
So will go to what I can say in 2013 and again, to see how it conflicts off.

40
00:02:35,060 --> 00:02:39,590
And that's it, and I hope this is now clear to you.

41
00:02:40,310 --> 00:02:46,760
And what we're doing is we're doing a very simple operation every time we are doing the right shift.

42
00:02:47,270 --> 00:02:48,620
OK, so we do it.

43
00:02:48,620 --> 00:02:50,520
And here this goes off.

44
00:02:50,540 --> 00:02:52,970
Next time these two bits are indirect, OK?

45
00:02:53,600 --> 00:02:54,080
And.

46
00:02:55,780 --> 00:03:00,130
Finally, we will get to one here, so this one is added to the count.

47
00:03:01,270 --> 00:03:08,410
So this we will do for all debates on voting no and the at most the number of segments is going to be

48
00:03:08,410 --> 00:03:09,290
long, often OK.

49
00:03:09,950 --> 00:03:17,930
The number of times this loop is going to run, it is going to run at most log, oftentimes a number.

50
00:03:17,950 --> 00:03:24,580
And because a number and has log of and but that you can easily verify by taking some example, let's

51
00:03:24,580 --> 00:03:26,860
say 16 16 is like this.

52
00:03:27,550 --> 00:03:29,590
Those 16 has.

53
00:03:30,250 --> 00:03:30,940
It's led to this.

54
00:03:31,010 --> 00:03:32,470
The ballot for it would have it.

55
00:03:32,470 --> 00:03:36,190
Most voters wondered if it's OK about seven.

56
00:03:36,700 --> 00:03:39,940
So it's going to be around two days to divide three.

57
00:03:40,120 --> 00:03:41,170
So seven is going to have it.

58
00:03:41,170 --> 00:03:43,210
Most attributes log off.

59
00:03:43,210 --> 00:03:44,590
Seven is close to three.

60
00:03:44,590 --> 00:03:46,300
Log of 16 is close to four.

61
00:03:46,780 --> 00:03:48,190
That's what I'm trying to say.

62
00:03:49,240 --> 00:03:53,140
So for any number, you have a log in bits and.

63
00:03:55,770 --> 00:04:03,120
OK, ground ground does not declared so this should be and B and yes, we are done and now we can actually

64
00:04:03,120 --> 00:04:11,700
run our code and see the dog slash gun because if I get 16 16, there's only one bullet if I get 15

65
00:04:11,700 --> 00:04:12,660
15 as voted.

66
00:04:12,660 --> 00:04:15,900
But if I give it, it has also one side of it.

67
00:04:16,620 --> 00:04:18,070
So that's all for this lecture.

68
00:04:18,090 --> 00:04:18,450
Thank you.
