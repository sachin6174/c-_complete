1
00:00:01,370 --> 00:00:06,560
Everyone in this video will talk about string comparison, which is an important concept, so let's

2
00:00:06,560 --> 00:00:07,790
say you're given those strings.

3
00:00:07,790 --> 00:00:13,140
Let's say some string, let's say hello and we some other string, let's say hi and you want to compare

4
00:00:13,250 --> 00:00:17,750
which string is larger or which string is smaller.

5
00:00:17,780 --> 00:00:25,670
So basically, when we compare strings, we basically talk in terms of equality, character by character

6
00:00:25,700 --> 00:00:25,910
again.

7
00:00:26,030 --> 00:00:32,630
For example, if I wanted to say two strings, they are exactly equal to each of the characters should

8
00:00:32,630 --> 00:00:35,420
match until you don't see analogy.

9
00:00:35,480 --> 00:00:38,180
So now let's present which we don't, right?

10
00:00:38,190 --> 00:00:42,320
But it does present in a regulator like this, OK?

11
00:00:42,800 --> 00:00:43,310
And what I want.

12
00:00:43,550 --> 00:00:46,760
Now, suppose I want to generate a very simple password.

13
00:00:46,760 --> 00:00:51,140
Typekit Maybe I have some passwords stored in my system.

14
00:00:51,150 --> 00:00:53,750
Let's say I have some expected password.

15
00:00:54,560 --> 00:00:55,160
It said.

16
00:00:55,220 --> 00:00:56,240
This is some string.

17
00:00:56,270 --> 00:00:58,790
It's a one zero one zero.

18
00:00:59,390 --> 00:00:59,690
OK.

19
00:01:00,380 --> 00:01:04,760
And maybe I want the user to enter some password.

20
00:01:04,940 --> 00:01:05,720
OK, oh sorry.

21
00:01:05,730 --> 00:01:06,610
This shouldn't be a.

22
00:01:08,690 --> 00:01:10,020
God's not expected by.

23
00:01:11,250 --> 00:01:17,520
Now, this is actually not a very it's just appointed to do what are you doing this spring if you want,

24
00:01:17,530 --> 00:01:19,080
you can make an area as well.

25
00:01:19,290 --> 00:01:27,570
So what I will do, I will again put some letters and I will store them, you know, Eric old password.

26
00:01:27,570 --> 00:01:28,440
OK, so what?

27
00:01:28,570 --> 00:01:30,150
I can again, design password.

28
00:01:31,630 --> 00:01:37,330
And I want to match whether these two are equal or not, OK, so maybe, maybe I can make a Boolean

29
00:01:37,330 --> 00:01:42,940
function so boolean and I can say, Oh, check the password.

30
00:01:44,540 --> 00:01:53,450
Where where I am getting Eric called password and I'm getting a pointer that is expected password.

31
00:01:53,990 --> 00:01:55,400
OK, guys, start expected.

32
00:01:56,040 --> 00:02:02,520
Now you may ask any name is also it 2.0, so we can also write it like this.

33
00:02:02,540 --> 00:02:08,480
It does not make it, but the way these two are stored in the memory, they are little different.

34
00:02:09,020 --> 00:02:13,370
Whereas the first one is a string that is stored in a read-only memory.

35
00:02:14,030 --> 00:02:19,730
And the second one is actually an array that is stored in your stock, right?

36
00:02:20,630 --> 00:02:25,160
And it can be updated because it's very it's not a constant string.

37
00:02:26,190 --> 00:02:33,110
But the Iranian is also blind, and the way we're storing this string little we are, we are great.

38
00:02:33,200 --> 00:02:37,440
We have created a poison pill that binds to this strong little tool that is also key.

39
00:02:37,920 --> 00:02:40,830
That means bypassing dual function.

40
00:02:41,400 --> 00:02:43,680
We can definitely send data like this.

41
00:02:44,130 --> 00:02:47,190
Maybe I want to compare the two passwords.

42
00:02:47,460 --> 00:02:50,820
Maybe I can say I want to return a Boolean.

43
00:02:50,820 --> 00:02:55,800
If the passwords are equal, I will return true or if they're not equal, I will return false.

44
00:02:55,920 --> 00:02:57,060
That is what I want to wait.

45
00:02:58,990 --> 00:03:09,490
And what I can do, I can say, OK, I have a string that is some some password, which is like one

46
00:03:09,490 --> 00:03:10,810
zero one zero.

47
00:03:11,320 --> 00:03:19,420
So we can either rover this using a, let's say, Index II, and we have some input password as well,

48
00:03:20,050 --> 00:03:23,140
which is getting stored in our area, right?

49
00:03:25,250 --> 00:03:30,110
And we can also trade over this, let's say this is also in Park one zero one zero.

50
00:03:31,100 --> 00:03:37,550
And then it would be like, maybe we can do that is there is also an index like we can use the same

51
00:03:37,610 --> 00:03:38,150
index, OK?

52
00:03:38,660 --> 00:03:40,990
We are going to match them location, location.

53
00:03:41,450 --> 00:03:45,530
And since it is read only, we can definitely read it and this ad is read plus, right?

54
00:03:45,830 --> 00:03:47,260
We can do both operations.

55
00:03:47,270 --> 00:03:47,540
OK?

56
00:03:48,140 --> 00:03:48,650
Maybe I can.

57
00:03:48,650 --> 00:03:49,810
To index.

58
00:03:49,820 --> 00:03:52,340
It starts from zero and I get do.

59
00:03:52,340 --> 00:03:56,530
While the buzzword of index, it does not equal to the.

60
00:03:57,740 --> 00:04:01,430
Unless we don't see a nail in the edit, we will.

61
00:04:01,550 --> 00:04:08,510
We are going to compare the two letters, look, if we can jack, if I sort of index, if it does not

62
00:04:08,510 --> 00:04:13,130
equal out any, any place, if it does not equal the expected password of index.

63
00:04:15,260 --> 00:04:17,810
So we can definitely say, OK, there is a mismatch.

64
00:04:18,020 --> 00:04:19,340
And we should return false.

65
00:04:19,880 --> 00:04:25,640
Otherwise, we will go to the next index and we'll do the matching once we come out of the loop, begin

66
00:04:25,640 --> 00:04:27,570
to return to the passwords.

67
00:04:27,590 --> 00:04:30,280
They do match and we are done right.

68
00:04:30,350 --> 00:04:40,580
So maybe we can see if some bad password we pass the password and the expected password if the match

69
00:04:41,600 --> 00:04:45,380
begins, OK, the old log in successful.

70
00:04:47,820 --> 00:04:53,340
And Al, and we can to else, maybe so try again.

71
00:04:54,700 --> 00:04:59,080
Now what I have done, I've built my own comparison function, right?

72
00:04:59,980 --> 00:05:01,300
So this should be done.

73
00:05:06,360 --> 00:05:10,350
Well, it's actually expected by word we give it here.

74
00:05:25,860 --> 00:05:28,140
OK, so there is a warning and there is an.

75
00:05:28,440 --> 00:05:34,140
So the return type is actually bull, the bull is the return type in C++ Boolean.

76
00:05:34,140 --> 00:05:35,350
Is it in Java, right?

77
00:05:35,940 --> 00:05:37,400
And there is a warning that.

78
00:05:40,210 --> 00:05:49,960
We missed out one records to C++, 11 does not allow this pointer to be created, but it is just a warning.

79
00:05:49,960 --> 00:05:56,800
It's not note it, which is OK, so we are kind of doing a conversion from a string letter to cards.

80
00:05:57,040 --> 00:06:05,140
So basically our God studies storing the location of a string letter, which is OK, we can do it and

81
00:06:05,350 --> 00:06:05,980
it's a warning.

82
00:06:05,980 --> 00:06:06,780
It's not an error.

83
00:06:06,820 --> 00:06:07,900
So we can run this code.

84
00:06:07,990 --> 00:06:10,400
So maybe we can go you.

85
00:06:11,540 --> 00:06:14,540
The vile name is in password checkered.

86
00:06:15,950 --> 00:06:21,830
Now we are it is waiting for password to get entered, so maybe hard one zero one zero two, it is log

87
00:06:21,830 --> 00:06:22,400
in success.

88
00:06:22,580 --> 00:06:31,120
Maybe I can say at 2020 it is driving, so we made an unsuccessful attempt to check the password, OK?

89
00:06:31,640 --> 00:06:36,370
That is how we can compare those strings later by later on.

90
00:06:36,380 --> 00:06:39,620
I hope you did understand this concept.

91
00:06:40,310 --> 00:06:48,020
Now one thing we will discuss is we can also use inbuilt comparison to compare to strings that will

92
00:06:48,020 --> 00:06:49,070
look in the next review.
