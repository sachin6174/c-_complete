1
00:00:01,170 --> 00:00:05,830
Everyone in this lecture, we're going to start dealing with a cat, Eddie.

2
00:00:05,880 --> 00:00:07,830
OK, so that's the area of correctness.

3
00:00:08,340 --> 00:00:13,920
Till now, what we were doing is we were reading certain characters, but we were not storing all of

4
00:00:13,920 --> 00:00:14,120
them.

5
00:00:14,130 --> 00:00:19,840
We were just storing a single character to get out in few problems or in a lot of problems.

6
00:00:19,860 --> 00:00:25,140
There might be a requirement to store the entire list of characters.

7
00:00:25,140 --> 00:00:28,320
Look, if, for example, you want to store the word hello.

8
00:00:29,560 --> 00:00:35,950
And maybe you want to do some updates on it, maybe later, later on, you want to say hello, followed

9
00:00:35,950 --> 00:00:40,300
by some knee, maybe OK, and you want to.

10
00:00:41,570 --> 00:00:42,680
Rent something.

11
00:00:42,710 --> 00:00:43,040
OK?

12
00:00:43,670 --> 00:00:45,560
The thing is, how do we store it?

13
00:00:45,560 --> 00:00:55,370
So one way of doing it is using the character is also known as the traditional the style strings, OK?

14
00:00:56,090 --> 00:01:04,400
And so he provides us C++, provides us the functionality to create an array in which every box or every

15
00:01:04,400 --> 00:01:06,200
book holds one.

16
00:01:06,590 --> 00:01:06,830
OK.

17
00:01:07,490 --> 00:01:13,820
And one thing that you need to remember about character areas is that they need to be terminated by

18
00:01:13,820 --> 00:01:14,540
a null character.

19
00:01:14,720 --> 00:01:15,950
So this is very important.

20
00:01:15,950 --> 00:01:24,650
We will see why it is important that no character is denoted as backslash zero and it has ASCII value

21
00:01:24,650 --> 00:01:25,030
of zero.

22
00:01:25,090 --> 00:01:27,020
Get it either ASCII will you.

23
00:01:27,500 --> 00:01:33,380
Basically, you need to put AI is stored as IDO or another character at the end of the city.

24
00:01:33,710 --> 00:01:33,960
OK.

25
00:01:34,640 --> 00:01:41,420
And these areas this support ID, write and update operations that mean you can put some data into the

26
00:01:41,420 --> 00:01:41,900
bucket.

27
00:01:41,930 --> 00:01:43,940
You can write some data.

28
00:01:44,660 --> 00:01:47,120
Obviously, you can read it and you can also update.

29
00:01:47,130 --> 00:01:52,700
You get to know, I don't want this to be I want this to be a school that is like update operation.

30
00:01:52,710 --> 00:01:55,760
So that is very important thing that we need to remember.

31
00:01:56,570 --> 00:02:00,870
On one, another thing that will frequently come across in your.

32
00:02:01,580 --> 00:02:07,520
Some of the goods is sometimes a stringers written in the quotes like this.

33
00:02:07,880 --> 00:02:09,770
You might see the Otello.

34
00:02:10,850 --> 00:02:11,150
OK.

35
00:02:11,850 --> 00:02:14,210
So is this a correct 30 countries?

36
00:02:14,250 --> 00:02:15,550
No, it's not a character.

37
00:02:16,580 --> 00:02:24,070
It's it's just a constant string, and it's no, it is a sequence of characters, but it is not a good

38
00:02:24,440 --> 00:02:25,040
character.

39
00:02:25,100 --> 00:02:25,430
OK.

40
00:02:25,880 --> 00:02:28,930
And it is stored in a read only memory.

41
00:02:28,940 --> 00:02:36,140
That means you cannot update this constant, OK, it's more like a godsend, and it is read only, right?

42
00:02:36,740 --> 00:02:39,470
Let me talk about the parts of the memory.

43
00:02:39,950 --> 00:02:42,520
So your when an application runs, OK?

44
00:02:43,580 --> 00:02:48,740
So your memory is divided into four segments.

45
00:02:49,010 --> 00:02:53,140
One is a stock segment where your function calls do happen.

46
00:02:53,780 --> 00:03:01,130
Another segment is the stock basically story or function calls and the local variables.

47
00:03:01,160 --> 00:03:06,290
That means any functions that are created inside our function.

48
00:03:06,710 --> 00:03:08,510
They would be part of the stock memory.

49
00:03:08,900 --> 00:03:16,010
There is a huge segment which also is having certain special properties like the dynamically created

50
00:03:16,010 --> 00:03:16,640
objects.

51
00:03:17,240 --> 00:03:19,400
They live on the heap, right?

52
00:03:19,640 --> 00:03:27,050
So basically all dynamic allocation or the allocation of memory during the runtime, that memory is

53
00:03:27,530 --> 00:03:36,560
occupied on the there is another segment which is known as a data segment, and there is another segment

54
00:03:36,560 --> 00:03:38,660
which is known as the text segment to get.

55
00:03:40,390 --> 00:03:45,250
Data segment does store like global variables, are static variables.

56
00:03:45,640 --> 00:03:54,070
All that data goes in the data segment and takes segment includes your executable instructions.

57
00:03:54,700 --> 00:03:55,000
OK.

58
00:03:56,200 --> 00:03:58,300
When you're running the application, you get it.

59
00:03:58,540 --> 00:04:01,260
It's just a set of lines of code.

60
00:04:01,500 --> 00:04:06,930
So all those lines there read only they're not going to change all the executable instructions.

61
00:04:07,230 --> 00:04:12,660
They go into the segment along with any string letters and can sense that you will create.

62
00:04:12,660 --> 00:04:19,500
So they're also read only OK, they are read only, and they also go into the next segment.

63
00:04:19,500 --> 00:04:19,740
OK?

64
00:04:20,580 --> 00:04:22,290
So basically, hello, are you?

65
00:04:22,290 --> 00:04:24,870
Write Later Index equal to five?

66
00:04:26,000 --> 00:04:28,280
Now here, two things that are happening.

67
00:04:28,550 --> 00:04:35,240
This is a five, which is an integer concerned, OK, but you're copying this value into a local variable.

68
00:04:35,750 --> 00:04:36,100
OK.

69
00:04:36,140 --> 00:04:40,100
Your initializing a local variable, which might mean something to let to mean.

70
00:04:40,730 --> 00:04:44,840
And this bucket is now creating this bucket, as announced during this value.

71
00:04:44,840 --> 00:04:45,170
Five.

72
00:04:45,530 --> 00:04:47,720
That bucket is created in the back.

73
00:04:48,080 --> 00:04:48,290
OK.

74
00:04:49,550 --> 00:04:57,290
So what I'm trying to say is that like you have integer concepts, we also have one since quantum strings,

75
00:04:57,530 --> 00:05:01,580
which are hidden in double codes and we call them as string letters, OK?

76
00:05:02,180 --> 00:05:04,850
And by default, they're null terminated.

77
00:05:05,780 --> 00:05:12,950
So that means even if, look, we have not drawn an alert, but at the storage level in the text segment,

78
00:05:12,950 --> 00:05:17,840
it is terminated when it does terminate with no character.

79
00:05:17,840 --> 00:05:19,610
So that is what string literal is.

80
00:05:19,610 --> 00:05:19,850
OK?

81
00:05:20,420 --> 00:05:20,810
Now.

82
00:05:22,370 --> 00:05:27,830
We have understood what is the meaning of null terminated, OK, so the corrected it is.

83
00:05:29,070 --> 00:05:35,940
If you are making a character study which will handle the storage for you, you need to terminate it

84
00:05:36,390 --> 00:05:37,560
with a null character.

85
00:05:38,680 --> 00:05:40,450
It's your responsibility to do it.

86
00:05:40,870 --> 00:05:46,960
But if you're creating a strange little does by having double code, it is not terminated automatically,

87
00:05:46,970 --> 00:05:47,220
OK?

88
00:05:47,560 --> 00:05:50,940
But the thing is, you can do, read and write on the correct.

89
00:05:52,030 --> 00:05:58,060
Plus any updates you can write, whereas a string literal it is read only.

90
00:05:58,060 --> 00:05:58,390
OK?

91
00:05:58,810 --> 00:05:59,830
It does not.

92
00:06:00,400 --> 00:06:01,510
It cannot be updated.

93
00:06:01,690 --> 00:06:03,940
It cannot be updated because it lives.

94
00:06:03,940 --> 00:06:05,680
You know, read only memory.

95
00:06:06,130 --> 00:06:13,870
OK, so when the program starts, this content gets loaded in read only memory and you cannot updated

96
00:06:13,870 --> 00:06:15,220
or you cannot override it.

97
00:06:15,220 --> 00:06:17,590
OK, so it will stay in the memory.

98
00:06:17,590 --> 00:06:18,820
It's read only string.

99
00:06:20,680 --> 00:06:27,640
Now, the thing is, then how do we create a character that is OK, so let us look at a few examples.

100
00:06:28,210 --> 00:06:36,370
So one way to do it is you define the character and using a lubricant, you initialize what this error

101
00:06:36,370 --> 00:06:36,720
is going.

102
00:06:36,740 --> 00:06:37,090
Do it.

103
00:06:37,130 --> 00:06:39,700
So let me show you a few examples.

104
00:06:40,150 --> 00:06:49,300
It's a name and name list, and the one thing we can do is let us try to see what does this area contain?

105
00:06:49,420 --> 00:06:49,690
Right?

106
00:06:50,470 --> 00:06:54,880
In order to bring the city, one thing we can do is we can use a loop.

107
00:06:55,120 --> 00:06:55,450
OK.

108
00:06:56,790 --> 00:07:03,210
Or C++ also supports that you can directly print a corrected array using code.

109
00:07:03,560 --> 00:07:07,070
You may ask how does the old print the editor look?

110
00:07:07,450 --> 00:07:11,400
So this is actually a special functionality.

111
00:07:11,660 --> 00:07:13,800
OK, a special functionality has been added.

112
00:07:14,160 --> 00:07:20,130
You see out there whenever you see an edit of the type correct, but do not print the address of that

113
00:07:20,150 --> 00:07:20,400
ilk.

114
00:07:20,400 --> 00:07:22,590
Do not print the starting point of there.

115
00:07:22,590 --> 00:07:27,570
Instead, you print everything inside the area until you find another character.

116
00:07:27,570 --> 00:07:35,040
OK, so by default, this character that we have created as name it contains 10 buckets.

117
00:07:36,390 --> 00:07:39,300
And we don't know what data it is going to contain.

118
00:07:39,690 --> 00:07:44,970
By default, it may contain zeros, it may contain garbage, it can contain anything, right?

119
00:07:45,480 --> 00:07:51,990
What this sealed function is going to do unless it finds another character in the memory, which might

120
00:07:51,990 --> 00:07:52,590
be at zero.

121
00:07:52,590 --> 00:07:57,300
The index, which might be at the first index, which might be at the seven index, it can.

122
00:07:57,300 --> 00:08:03,290
With an index, it is just going to print everything until it finds a null character.

123
00:08:03,300 --> 00:08:03,540
OK?

124
00:08:03,750 --> 00:08:06,460
So that is what this code statement is going to do.

125
00:08:06,510 --> 00:08:07,410
So let me show you.

126
00:08:07,770 --> 00:08:13,110
So it faces the old name, and I've not done any initialization till now, right?

127
00:08:14,090 --> 00:08:15,500
So let me try to run this code.

128
00:08:16,450 --> 00:08:20,980
On dogs like God -- war, buddy.

129
00:08:22,190 --> 00:08:24,860
I just ran the wrong program.

130
00:08:25,130 --> 00:08:28,390
It's not like God added them.

131
00:08:30,880 --> 00:08:31,300
Hmm.

132
00:08:32,010 --> 00:08:33,270
Let's build a good first.

133
00:08:35,950 --> 00:08:37,840
And now you can see.

134
00:08:40,380 --> 00:08:46,380
So it is actually an integer that in this case, what we are getting, we are getting the address of

135
00:08:46,380 --> 00:08:47,490
our own budgetary, OK.

136
00:08:47,790 --> 00:08:50,910
So this is what she does in case of war in digitally.

137
00:08:51,390 --> 00:08:53,740
But let me change it to work on activity.

138
00:08:54,250 --> 00:08:56,040
And let me try to show you the code.

139
00:08:56,970 --> 00:09:06,090
In this case, it is not giving me any output, which means it did found a null at the zero two place

140
00:09:06,630 --> 00:09:07,440
and building the code.

141
00:09:07,770 --> 00:09:09,350
It is not giving any output.

142
00:09:09,360 --> 00:09:15,030
OK, so it did found in the zero three NICS and that is why it is working like this.

143
00:09:15,510 --> 00:09:18,770
Let me initialize this array with the name OK.

144
00:09:19,110 --> 00:09:27,570
The Wenham initializing I can skip giving the size of the city, which is now optional.

145
00:09:28,570 --> 00:09:29,650
And you can do.

146
00:09:29,890 --> 00:09:31,750
It is giving me the output that the.

147
00:09:33,770 --> 00:09:40,680
OK, now there is one concern that we want to know whether this is null, terminated or not.

148
00:09:40,700 --> 00:09:43,940
Okay, so let us see what I what I'm going to do.

149
00:09:44,360 --> 00:09:51,660
Maybe I can use a function which gives me the length of this area, OK, the length of the edit.

150
00:09:52,520 --> 00:10:00,680
There is a method which is known as Strange Land, SDR Alien and I passed the area to this and it will

151
00:10:00,680 --> 00:10:06,570
tell me how many buckets it has used bestowed this particular string.

152
00:10:06,630 --> 00:10:09,230
OK, so let us try to see the output.

153
00:10:10,660 --> 00:10:16,810
It is saying that they use seven buckets to store this particular string, they.

154
00:10:18,170 --> 00:10:24,860
Though it is giving us the output, but there is one special thing that I want you to remember about

155
00:10:24,860 --> 00:10:26,330
the Sierra Leone function.

156
00:10:27,110 --> 00:10:29,420
It does not count the Nile.

157
00:10:29,420 --> 00:10:32,420
Look at it while calculating the land OK, so effectively.

158
00:10:32,420 --> 00:10:40,500
If even if it is a bit big and what we have did is we have initialized corrected it using a string literal.

159
00:10:40,520 --> 00:10:40,880
OK.

160
00:10:41,720 --> 00:10:44,980
And what we discussed the string literals.

161
00:10:45,500 --> 00:10:50,150
They are not returning the goods and the note that we need to look at.

162
00:10:50,420 --> 00:10:51,230
What does it mean?

163
00:10:51,350 --> 00:11:02,990
Effectively inside the character that we did copy all the letters B, D E J and the character is also

164
00:11:02,990 --> 00:11:06,890
copied, but the learned function is written such don't.

165
00:11:07,280 --> 00:11:10,550
It will count everything until it hits.

166
00:11:10,550 --> 00:11:17,640
Then again, so this knowledge is not counted effectively the that it must be having a safe that.

167
00:11:17,660 --> 00:11:18,350
Is it right?

168
00:11:20,110 --> 00:11:25,270
Now, coming back to some other ways of initializing, so that is one way of doing it.

169
00:11:25,420 --> 00:11:30,430
You are the finest wrinkly little anchor brackets and you created it.

170
00:11:30,530 --> 00:11:34,660
OK, maybe I can say God name.

171
00:11:35,560 --> 00:11:36,670
It's a company, right?

172
00:11:39,250 --> 00:11:46,630
And I say, OK, I want to initialize this string, so I have to give it here.

173
00:11:50,060 --> 00:11:56,920
I have to define got followed by square brackets like we create a regulatory and what we are going to

174
00:11:56,920 --> 00:11:57,130
do.

175
00:12:01,250 --> 00:12:09,170
But not not yet, but apparently I was boarding in Dover, Delaware, has a different notation, so

176
00:12:09,170 --> 00:12:11,620
God company, I define good.

177
00:12:11,630 --> 00:12:16,370
This is an area that can hold up to 200 letters, OK?

178
00:12:16,940 --> 00:12:20,630
Or maybe what I can do, I can do this is equal to according minutes.

179
00:12:21,750 --> 00:12:26,310
So let me just, Brent, if we are able to initialize company correctly or not.

180
00:12:28,400 --> 00:12:30,340
Maybe if I underscored.

181
00:12:31,220 --> 00:12:33,600
Yes, we do get the output quoting minutes.

182
00:12:34,010 --> 00:12:39,440
So here again, what we have done, we have used a string literal, which is knowledge that we need

183
00:12:39,440 --> 00:12:39,920
to look at.

184
00:12:40,340 --> 00:12:49,910
Let me show you another way of doing the initialization may be God lets in done name something and I

185
00:12:49,910 --> 00:12:50,470
say OK.

186
00:12:52,010 --> 00:12:56,990
The name of the end is not defined as a list of categories, maybe are.

187
00:12:59,720 --> 00:13:08,090
Some X that you'll get some x y z, and in this case, I have explicitly defined the list of characters

188
00:13:08,690 --> 00:13:12,950
that will go inside my edit that is name of the intern.

189
00:13:13,760 --> 00:13:14,870
And what I will do.

190
00:13:15,080 --> 00:13:20,590
I will still vote, though, in denim, in the similar fashion.

191
00:13:20,600 --> 00:13:20,860
OK?

192
00:13:20,900 --> 00:13:23,120
So let us try to see what output do we get?

193
00:13:24,650 --> 00:13:31,490
All right, though, we are getting X-rays, but we can get something else as well, maybe I have X,

194
00:13:31,490 --> 00:13:32,810
Y, Z and D.

195
00:13:34,070 --> 00:13:35,060
Let me run this.

196
00:13:37,370 --> 00:13:37,760
OK.

197
00:13:38,120 --> 00:13:39,890
And let me remove the.

198
00:13:44,330 --> 00:13:50,100
Just a matter of chance that we are getting to see an output like this by default, what is going to

199
00:13:50,100 --> 00:13:51,160
happen in this case?

200
00:13:51,360 --> 00:13:51,570
It.

201
00:13:52,750 --> 00:13:57,850
So in Dunn name is Eddie, which is sporting three letters.

202
00:13:59,240 --> 00:14:04,970
And there can be a when when you're printing the internet.

203
00:14:05,600 --> 00:14:14,750
It is starting from the 03 index and it is going to read in the memory until it finds an OK, even if

204
00:14:14,750 --> 00:14:17,620
this is outside the boundaries of the area.

205
00:14:21,030 --> 00:14:26,340
It will not get to know till what later to print, because the printing algorithm, which has been buried

206
00:14:26,340 --> 00:14:33,440
inside out it reads the area a little bit later until it finds an ally to what is going to happen.

207
00:14:33,880 --> 00:14:38,640
So in some other cases, you can get x y z, followed by garbage.

208
00:14:39,130 --> 00:14:40,710
The where is this garbage coming from?

209
00:14:40,760 --> 00:14:42,360
It doesn't come from this place, OK?

210
00:14:42,870 --> 00:14:46,200
They're just a matter of chance this time that we are not getting our garbage.

211
00:14:46,740 --> 00:14:53,320
But it is very likely, or it is very much possible that when you run this code on your system, you

212
00:14:53,340 --> 00:14:56,010
see this kind of output x y z garbage.

213
00:14:56,310 --> 00:15:02,610
This is happening because in the third case, when we are initializing the internet, it does not know

214
00:15:02,610 --> 00:15:06,300
that we need to look if we have to explicitly put an alert.

215
00:15:07,560 --> 00:15:13,020
Now, if heard and the good now it is correct, because if you are initializing your character study

216
00:15:13,020 --> 00:15:19,110
using a list of characters, please do define another character at the end of that, OK?

217
00:15:19,350 --> 00:15:29,610
So for the first two initial positions, the null is not mandatory, OK, but so that is a quick introduction

218
00:15:29,610 --> 00:15:34,800
about corrected errors and in the next lecture will continue working with corrected areas and we'll

219
00:15:34,800 --> 00:15:38,430
look at some more functions to work on corrected errors.
