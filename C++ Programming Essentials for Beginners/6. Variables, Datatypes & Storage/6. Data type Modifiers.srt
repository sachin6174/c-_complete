1
00:00:01,860 --> 00:00:06,570
Everyone's in this lecture, we're going to talk about one important concept, which is known as data

2
00:00:06,570 --> 00:00:09,110
type modifiers in C++.

3
00:00:09,360 --> 00:00:15,900
We have something which is known as auditor type modify, and it allows us to expand or decrease the

4
00:00:15,900 --> 00:00:21,870
capacity of the boxes or the buckets that we have been allocating for integers, OK, or for other data

5
00:00:21,870 --> 00:00:22,530
types as well.

6
00:00:22,990 --> 00:00:26,990
So some of the data does work.

7
00:00:27,030 --> 00:00:34,800
So let me just tell you what example is the boys wanted to create an integer and by default it gives

8
00:00:34,800 --> 00:00:36,990
me 32 bits.

9
00:00:37,170 --> 00:00:37,440
OK?

10
00:00:37,890 --> 00:00:39,270
It gives me a 32 bit bucket.

11
00:00:39,750 --> 00:00:47,070
I suppose I wanted to create a larger integer, so we know that it will not draw a number which contains

12
00:00:47,070 --> 00:00:47,740
more than that.

13
00:00:47,870 --> 00:00:56,730
But there is another option to either modify it in front of it that we call as long long.

14
00:00:57,870 --> 00:01:02,850
It gives you the biggest budget, which which will contain 64 bit sugar.

15
00:01:03,660 --> 00:01:08,860
That means you can store a number up to 64 bit inside the bucket called long, long.

16
00:01:08,910 --> 00:01:13,020
So this long long is a data type modified OK.

17
00:01:14,130 --> 00:01:15,660
Or you can alter this shortened.

18
00:01:17,060 --> 00:01:24,980
Maybe you you're working on a concept where you're storing some data that only requires age of the person

19
00:01:24,980 --> 00:01:25,580
to be stored.

20
00:01:26,330 --> 00:01:32,300
You know that to age must be in the range, let's say, zero to 120 years, OK?

21
00:01:33,620 --> 00:01:39,170
Now what this will do, it will give you a smaller size bucket, OK, so what is the exact size we can

22
00:01:39,170 --> 00:01:40,580
check on our machine?

23
00:01:41,120 --> 00:01:46,310
So the way we can check it, we are going to go to our order.

24
00:01:47,420 --> 00:01:51,050
And we are going to say, OK, let me create a shortened.

25
00:01:53,810 --> 00:01:55,460
Maybe shot in.

26
00:01:56,680 --> 00:01:57,160
Age.

27
00:01:58,910 --> 00:02:02,980
And I can say, OK, give me the size of each.

28
00:02:03,410 --> 00:02:07,580
How much memory you're going to allocate for this shortened.

29
00:02:07,820 --> 00:02:12,860
So let us verify by running this code on terminal and.

30
00:02:14,580 --> 00:02:17,730
We have built a gold as well, so dodge slash.

31
00:02:18,860 --> 00:02:19,940
Size of demo.

32
00:02:21,020 --> 00:02:25,820
So short, you're going to hear this taking two bites, that means it is allocating.

33
00:02:28,750 --> 00:02:32,920
How much it is allocating estimates for this number?

34
00:02:33,280 --> 00:02:36,310
Similarly, you can verify for long, long as well, right?

35
00:02:37,400 --> 00:02:41,240
You can verify for long, long as well.

36
00:02:41,570 --> 00:02:44,780
It may be long and so and long, long and let's.

37
00:02:46,630 --> 00:02:48,400
What happened in this case?

38
00:02:52,230 --> 00:02:59,250
Maybe I can give how much memory you allocate if I create a long and digit or if I create a long, long

39
00:02:59,250 --> 00:02:59,820
integer.

40
00:03:00,090 --> 00:03:03,240
OK, so let's run this code.

41
00:03:04,830 --> 00:03:11,590
So bored and gaze of longing on long, long, it is giving me aid bytes of memory.

42
00:03:11,610 --> 00:03:18,720
That means it is giving me 64 bit basically in this system, the longest seem as long long will.

43
00:03:19,440 --> 00:03:23,250
And these things are basically your system dependent.

44
00:03:23,250 --> 00:03:25,590
So that's why we are checking how much it is.

45
00:03:25,920 --> 00:03:34,500
But the idea is that long would give you a memory that is greater than equal to the memory of the individual,

46
00:03:34,500 --> 00:03:34,740
OK?

47
00:03:35,280 --> 00:03:40,820
On short will give you a memory that is less than equal to the memory of integer bucket.

48
00:03:42,390 --> 00:03:49,470
And by having a larger bucket, you can also increase the range of the largest number that can be stored

49
00:03:49,470 --> 00:03:50,520
in that particular bucket.

50
00:03:51,090 --> 00:03:56,040
So very soon we will talk about what is the largest and what is the smallest number that can be stored.

51
00:03:56,700 --> 00:03:59,640
But before that, there are two more things that we would like to cover.

52
00:04:00,300 --> 00:04:04,980
There is also a concept of a signed integer under unsigned integer.

53
00:04:04,980 --> 00:04:05,240
OK?

54
00:04:05,760 --> 00:04:12,480
What is the meaning of signed on unsigned to by default, all integers are trying to get if you write,

55
00:04:12,480 --> 00:04:14,490
OK, I am talking about assigning digits.

56
00:04:14,520 --> 00:04:21,630
That means that integer is capable of storing both the positive numbers and the negative numbers.

57
00:04:21,660 --> 00:04:24,960
If you say X is plus five, it is going to store it.

58
00:04:25,320 --> 00:04:29,250
If you don't know, my X is minus five, it is also going to store it because.

59
00:04:30,280 --> 00:04:36,460
All integers, by default, they're capable of storing both the designed positive numbers and the negative

60
00:04:36,460 --> 00:04:37,060
numbers, OK?

61
00:04:37,570 --> 00:04:39,760
Now how does it differ?

62
00:04:39,840 --> 00:04:40,900
OK, how does it differ?

63
00:04:40,960 --> 00:04:47,170
The one one difference between the positive numbers and the negative numbers is that if you have a 32

64
00:04:47,170 --> 00:04:54,340
bit bucket, OK, then the 31 bits they are used to store the magnitude of the number, let's say the

65
00:04:54,340 --> 00:04:55,210
number is five.

66
00:04:55,750 --> 00:05:02,080
OK, then the remaining bits that the first bit, which is also known as the most significant bit.

67
00:05:03,150 --> 00:05:10,260
This is actually used as the sign read, OK, this is actually used as designed by the convention.

68
00:05:10,590 --> 00:05:14,460
If the sign was zero, it denote a positive number.

69
00:05:15,030 --> 00:05:17,790
But if this sign is one, it denotes a negative.

70
00:05:18,090 --> 00:05:22,410
OK, if the sign is one, it is going to denote the negative number.

71
00:05:23,130 --> 00:05:25,940
So that is the idea of a signed integer.

72
00:05:26,430 --> 00:05:30,840
But if I talk about an unsigned integer, OK, so what happens in an integer?

73
00:05:31,320 --> 00:05:35,010
All 32 bits are used to store the magnitude of the number.

74
00:05:35,040 --> 00:05:38,280
It only stores the numbers, which are greater than equal to zero.

75
00:05:39,190 --> 00:05:41,640
What example if you want to store a roll number of a person?

76
00:05:41,940 --> 00:05:48,630
OK, you might use an unsigned integer, do you using A. There is also fine, but rule numbers cannot

77
00:05:48,630 --> 00:05:49,150
be negatives.

78
00:05:49,170 --> 00:05:51,480
Are I just created an unsigned integer bucket?

79
00:05:51,650 --> 00:05:51,930
OK.

80
00:05:53,010 --> 00:05:58,260
But for most use cases writing the regular rate, it is going to work fine.

81
00:05:58,800 --> 00:06:04,050
And it is only very corner cases where you might require to work with an unsigned integer.

82
00:06:04,050 --> 00:06:04,290
OK?

83
00:06:04,800 --> 00:06:11,700
But for all your programming, you can work with the regular integers as to let me just tell you the

84
00:06:11,700 --> 00:06:17,430
difference between the signed integer and unsigned integer so you can have signed end.

85
00:06:18,740 --> 00:06:20,390
Or in what are seen.

86
00:06:21,660 --> 00:06:21,930
OK.

87
00:06:22,470 --> 00:06:30,000
And if you want to go get no, I don't want the first bit to denote the magnitude of the number or not,

88
00:06:30,000 --> 00:06:36,570
the sign of the number, then all 32 little bits will be used to denote the magnitude of the number,

89
00:06:36,570 --> 00:06:36,810
OK?

90
00:06:37,200 --> 00:06:43,830
That means if you have one hit or something, something something like this, then this number is going

91
00:06:43,830 --> 00:06:43,980
to.

92
00:06:44,400 --> 00:06:51,630
This one is going to contribute to raise to the bar 31 in the answer, OK, but hit the first bit as

93
00:06:51,630 --> 00:06:52,730
a result for the sign.

94
00:06:53,160 --> 00:06:59,330
If it is one, then you have some numbers, then this does not contribute to raise to the bar 31 dedans

95
00:06:59,340 --> 00:07:01,090
that it contributes a negative sign.

96
00:07:01,110 --> 00:07:03,240
It means it is a negative number.

97
00:07:03,540 --> 00:07:09,480
OK, and if the first bit of zero, then it means it is a positive number.

98
00:07:09,480 --> 00:07:13,770
OK, so this number has the first zero.

99
00:07:13,800 --> 00:07:17,910
It means that as a positive numbers, it represents less fate.

100
00:07:18,780 --> 00:07:20,190
And what does it represent?

101
00:07:20,430 --> 00:07:25,950
We will discuss very, very shortly, but we will also talk about the storage of negative numbers,

102
00:07:25,950 --> 00:07:27,710
how the negative numbers are stored.

103
00:07:27,810 --> 00:07:29,520
It is unsigned integer, OK.

104
00:07:30,300 --> 00:07:37,590
You can also add two more modifiers you can unsigned, long, OK, unsigned long.

105
00:07:37,590 --> 00:07:43,470
And what it means Create a bucket of size 64 bits.

106
00:07:44,850 --> 00:07:49,080
And in this book, the first bit does not represent the sign.

107
00:07:49,110 --> 00:07:53,500
It also represents a power of two that isn't meaning of one's own logic.

108
00:07:53,820 --> 00:07:57,480
That means you can store a bigger number inside this bunker.

109
00:07:57,550 --> 00:07:57,810
OK.

110
00:07:58,440 --> 00:08:03,990
And we'll discuss what is the range of these numbers, how big the number can be.

111
00:08:04,790 --> 00:08:12,660
And yeah, very soon in the next lecture that was all about this video you can also use.

112
00:08:14,870 --> 00:08:18,580
Along with other data types like Double, you can say I want along.

113
00:08:19,040 --> 00:08:22,700
OK, so I'll show you the examples in the coming lectures.

114
00:08:22,850 --> 00:08:24,050
That's all for this video.

115
00:08:24,060 --> 00:08:24,590
Thank you.
