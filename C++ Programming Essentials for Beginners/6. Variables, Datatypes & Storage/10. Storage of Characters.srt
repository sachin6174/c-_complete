1
00:00:01,590 --> 00:00:07,650
Everyone's in this lecture, we're going to talk about the storage of collectors, OK, so these are

2
00:00:07,650 --> 00:00:14,910
some of the possible connectors that you can have in your C++ program, and the way you can create a

3
00:00:14,910 --> 00:00:20,400
character is defined, not gather today and create a bucket that is going to store the character or

4
00:00:20,400 --> 00:00:23,550
give, for example, akin to got some bucket.

5
00:00:24,150 --> 00:00:27,660
And this bucket is going to store the later the characters.

6
00:00:27,660 --> 00:00:29,280
They are defined in single codes.

7
00:00:29,970 --> 00:00:34,890
And what you need to know is the size of the character is one bite, right?

8
00:00:35,340 --> 00:00:37,200
That means a bit.

9
00:00:37,950 --> 00:00:43,080
But let us try to understand how this character is actually stored inside the memory.

10
00:00:43,440 --> 00:00:44,490
It's not like that.

11
00:00:44,490 --> 00:00:47,040
You are actually storing it inside a bucket.

12
00:00:47,070 --> 00:00:49,920
No, it's not the all characters.

13
00:00:50,310 --> 00:00:52,380
They are mobbed with integers.

14
00:00:52,690 --> 00:00:53,010
OK.

15
00:00:53,610 --> 00:00:56,580
Three-Word Table, which is known as as their table.

16
00:00:56,900 --> 00:00:57,150
OK.

17
00:00:57,570 --> 00:01:04,690
So it's international standard that defines a mapping between each character and its numeric value.

18
00:01:04,710 --> 00:01:09,660
For example, the capital is denoted using the value 65.

19
00:01:10,590 --> 00:01:12,620
The Capital B is nothing but 66.

20
00:01:13,110 --> 00:01:16,530
ABDEL-ATI is nothing but 67 and so on.

21
00:01:16,800 --> 00:01:22,830
Similarly, the small is denoted using 97 small ways, using 98 and so on.

22
00:01:22,920 --> 00:01:23,190
OK.

23
00:01:23,850 --> 00:01:27,720
So talking in total, look at the set of characters.

24
00:01:27,780 --> 00:01:29,730
OK, how many numbers we will need?

25
00:01:31,310 --> 00:01:32,610
The total debt of this.

26
00:01:33,850 --> 00:01:36,070
Is less than equal to 255.

27
00:01:36,130 --> 00:01:45,130
That means if we have the numbers from zero to 255, that is more than enough to represent all the unique

28
00:01:45,130 --> 00:01:48,070
characters that we can have inside the C++ program.

29
00:01:48,490 --> 00:01:48,760
OK.

30
00:01:50,100 --> 00:01:50,760
So.

31
00:01:52,490 --> 00:01:54,110
So what what does it mean?

32
00:01:54,140 --> 00:02:01,850
So we need to represent 255 unique combinations, zero to 255, that means we need to represent 256

33
00:02:02,030 --> 00:02:03,610
unique combinations, OK?

34
00:02:04,190 --> 00:02:09,050
And how many boots would be required to store these many combinations?

35
00:02:09,530 --> 00:02:15,920
Of course, if we have eight bit bucket, we can make 256 combinations.

36
00:02:16,040 --> 00:02:17,450
That is, to raise the debilitate.

37
00:02:17,660 --> 00:02:23,810
We can have 256 combinations and these combinations will represent different characters, OK?

38
00:02:24,380 --> 00:02:29,780
And that is why the characters are going to take one bite of memory because each character is going

39
00:02:29,780 --> 00:02:34,400
to be mapped with their own budget that indeed there is going to get stored inside the memory.

40
00:02:34,970 --> 00:02:40,660
And when we are going to read that number, how do we know whether it is a number or is it connected

41
00:02:41,300 --> 00:02:44,150
to it will be known through this data type.

42
00:02:44,240 --> 00:02:47,270
OK, so if I say see out this bucket.

43
00:02:50,110 --> 00:02:56,530
I will see the answer, but if I took put the contents of this bucket into some endangered bucket,

44
00:02:56,530 --> 00:03:00,220
OK, let's say my bucket and this is equal to the bucket.

45
00:03:00,760 --> 00:03:06,220
And if I see out my bucket what I'm going to get, I'm going to get the integer value.

46
00:03:06,580 --> 00:03:07,210
Let me show you.

47
00:03:08,390 --> 00:03:10,280
Let me show you the output here.

48
00:03:12,760 --> 00:03:13,510
If I now.

49
00:03:15,340 --> 00:03:16,060
Bill, that's good.

50
00:03:16,750 --> 00:03:20,710
And if I try to run it, you can see the correct that is.

51
00:03:21,430 --> 00:03:26,470
But if I try to put this insider in the bucket, it's only going to copy the integer right?

52
00:03:27,220 --> 00:03:32,200
Both the buckets, this is bucket and this is my bucket.

53
00:03:33,580 --> 00:03:40,690
This is of the type God, this is of the type, and this is starting 65mm and I'm doing put this number

54
00:03:40,690 --> 00:03:40,900
here.

55
00:03:41,230 --> 00:03:42,460
It is a whopping 65.

56
00:03:43,390 --> 00:03:46,750
But when I'm saying will get Brent this bucket or the old this bucket?

57
00:03:47,990 --> 00:03:55,130
So it is actually showing the output as a because the database got the day-to-day was telling this CO2

58
00:03:55,130 --> 00:03:56,820
statement, OK, isn't entered as a God.

59
00:03:56,870 --> 00:03:58,940
You don't bring the integer value of it.

60
00:03:59,480 --> 00:04:02,740
What do you print what this character represent?

61
00:04:02,840 --> 00:04:03,740
So this represents.

62
00:04:04,010 --> 00:04:04,340
OK.

63
00:04:04,850 --> 00:04:08,230
Similarly, here, the data they put into that is where we see the output as.

64
00:04:09,590 --> 00:04:12,100
That is how the characters are stored.

65
00:04:12,110 --> 00:04:13,950
And I hope you got an idea.

66
00:04:14,480 --> 00:04:21,830
And you also get to know that there are maximum 256 unique combination of characters that we will need

67
00:04:22,460 --> 00:04:29,810
and that can be represented using eight bit bucket and hence the character takes one bite of memory,

68
00:04:29,810 --> 00:04:31,020
at least in C++.

69
00:04:31,040 --> 00:04:31,280
OK.

70
00:04:31,730 --> 00:04:38,510
In other languages like Java, Java, the set of characters, the support Unicode characters with which

71
00:04:38,510 --> 00:04:44,870
is it also supports different characters like the characters from other languages in Java.

72
00:04:44,870 --> 00:04:45,200
OK?

73
00:04:45,590 --> 00:04:52,310
So you can use the Hindi letters as well so you can create strings using the in the letters or the rupee

74
00:04:52,310 --> 00:04:55,800
symbol or rational position in Java.

75
00:04:55,820 --> 00:04:58,040
The character actually takes two bytes.

76
00:04:58,430 --> 00:04:58,730
OK.

77
00:04:59,810 --> 00:05:01,520
It means it has 16 bit.

78
00:05:01,640 --> 00:05:03,980
So again, it's a language specific thing.

79
00:05:04,250 --> 00:05:11,630
In C++, we have a smaller set of characters and that is for that aid, which are sufficient enough.

80
00:05:12,650 --> 00:05:14,520
So that's all for this video on.

81
00:05:14,540 --> 00:05:15,080
Thank you.
