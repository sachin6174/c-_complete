1
00:00:01,920 --> 00:00:02,550
Hello, everyone.

2
00:00:02,590 --> 00:00:07,590
And now we are going to see the storage of the bullion there today because we have seen in the world

3
00:00:07,590 --> 00:00:07,950
God.

4
00:00:08,400 --> 00:00:11,070
And this time we are going to see the storage of bullion, right?

5
00:00:12,100 --> 00:00:19,330
So the thing with bullying is you can represent true or false, which would ideally require only one,

6
00:00:19,340 --> 00:00:20,150
but OK.

7
00:00:21,100 --> 00:00:26,650
But but that being said, the actual storage is not one bit, it is actually one bite.

8
00:00:27,160 --> 00:00:27,460
OK.

9
00:00:28,030 --> 00:00:32,650
That means if you're studying something like true, true is being stored, something like this.

10
00:00:32,800 --> 00:00:39,310
Zero zero zero zero zero zero one two one two three four five six seven eight.

11
00:00:39,340 --> 00:00:44,740
So you're using it, but the stored this value true, and we're talking about false.

12
00:00:45,460 --> 00:00:47,890
It would be stored as lots of euros, OK?

13
00:00:48,370 --> 00:00:54,550
Now you may ask why why the compiler is doing this, why it is allocating one by one byte is actually

14
00:00:54,730 --> 00:00:56,380
the minimum unit.

15
00:00:58,260 --> 00:01:04,620
In which you can allocate memory to it as the minimum unit, or it is a minimum size of the bucket that

16
00:01:04,620 --> 00:01:05,670
can be allocated.

17
00:01:05,680 --> 00:01:11,610
So that is why even though the Boolean requires one bit, the compiler allocates the minimum bucket

18
00:01:11,610 --> 00:01:14,230
size that is one, right?

19
00:01:14,250 --> 00:01:14,550
OK?

20
00:01:15,120 --> 00:01:17,400
But examples of what you want to buy bananas will get.

21
00:01:17,820 --> 00:01:20,050
Maybe you can buy four bananas.

22
00:01:20,070 --> 00:01:24,840
Maybe you can buy eight bananas, but somehow you just want to buy 8.1 bananas.

23
00:01:24,840 --> 00:01:28,680
You can and buy two 'cause you have to buy at least one bananas.

24
00:01:28,680 --> 00:01:35,550
So the minimum unit of this memory allocation happens to be one bite, and that is the reason the bullion

25
00:01:35,850 --> 00:01:39,360
does take one bite of memory.

26
00:01:39,780 --> 00:01:42,570
Talking about the code, we have seen that this Boolean.

27
00:01:42,720 --> 00:01:47,010
It takes one bite, and I will just tell you one more thing about the billions.

28
00:01:47,010 --> 00:01:51,990
If you store something like this, let's say boolean some value.

29
00:01:53,500 --> 00:01:55,780
And I put this as a non-zero value.

30
00:01:56,290 --> 00:02:01,450
The non-zero value in C++ is rated as true.

31
00:02:02,260 --> 00:02:02,590
OK.

32
00:02:03,250 --> 00:02:10,210
So it is not going to store five, maybe let's see what it is going to store when we see out some value.

33
00:02:11,140 --> 00:02:13,060
This should be treated as true.

34
00:02:14,570 --> 00:02:15,950
And if I underscored.

35
00:02:17,610 --> 00:02:23,190
Well, guess what, you can see this value is being stored as one only that means any non-zero value

36
00:02:23,190 --> 00:02:28,140
is being treated as true by the C++ compiler.

37
00:02:28,370 --> 00:02:30,150
OK, this is how it is getting stored.

38
00:02:30,150 --> 00:02:32,430
It is getting stored as one only.

39
00:02:32,430 --> 00:02:33,960
So this value this one.

40
00:02:34,620 --> 00:02:36,950
This is how the truest or it.

41
00:02:37,320 --> 00:02:40,710
And similarly, you can see what files it is stored as 0nly.

42
00:02:41,490 --> 00:02:42,660
That's all for this video.

43
00:02:42,660 --> 00:02:42,990
Thank you.
