1
00:00:01,550 --> 00:00:07,790
Everyone, till now, we have learned about three functions contractor, copy and copy assignment operator

2
00:00:07,790 --> 00:00:10,790
and the fourth one that is also present in every class.

3
00:00:11,270 --> 00:00:12,620
This is known as destructor.

4
00:00:13,010 --> 00:00:14,980
So you're going to talk about the structure.

5
00:00:14,990 --> 00:00:20,590
So the structure is written something like this, the class name prefixed with this delectable design.

6
00:00:21,200 --> 00:00:26,120
And here what we are going to do that we are going to write the code for.

7
00:00:27,590 --> 00:00:30,110
Deleting the dynamically allocated memory.

8
00:00:31,070 --> 00:00:37,160
So any static data that is created that is automatically destroyed, but in order to create dynamically

9
00:00:37,160 --> 00:00:41,810
allocated memory, we need to write this code inside the truck that will get.

10
00:00:43,080 --> 00:00:50,080
Because dieting memories freed by the non-violent and dynamic memory is the job of the user program

11
00:00:50,520 --> 00:00:56,010
it will destroy, it is a function that is called automatically when the object is destroyed or for

12
00:00:56,010 --> 00:01:00,090
example, we were making a product object and then the main function is finished.

13
00:01:00,690 --> 00:01:08,310
And since product, as it's called domain, that object will be destroyed and their the for the product

14
00:01:08,310 --> 00:01:09,390
will be called OK.

15
00:01:09,690 --> 00:01:12,930
The compiler provides a default constructor on user need.

16
00:01:14,050 --> 00:01:19,770
A user defined structure is needed when the class content pointers to dynamically allocated memory,

17
00:01:19,780 --> 00:01:23,170
so this is something that we have to take care of.

18
00:01:23,710 --> 00:01:27,670
Let me show you this example that we have written in this example.

19
00:01:27,820 --> 00:01:33,220
If I talk about what are the things that are dynamically allocated, so only the name of the product

20
00:01:33,250 --> 00:01:34,450
is dynamically allocated.

21
00:01:34,450 --> 00:01:41,680
So that means we need to provide the code for the destructed to destroy the name when the object goes

22
00:01:41,680 --> 00:01:42,370
out of scope.

23
00:01:43,540 --> 00:01:49,360
So let me just write a district that they'd say, delete the product.

24
00:01:49,780 --> 00:01:52,810
Maybe I can to see out or deleting.

25
00:01:53,380 --> 00:01:56,680
And maybe you can say a product name, so maybe name.

26
00:01:58,100 --> 00:02:04,250
Now, we have not called this function, but this function will be called automatically when the object

27
00:02:04,250 --> 00:02:05,290
goes out of scope.

28
00:02:05,360 --> 00:02:11,330
We're just before this function hits the ending block.

29
00:02:11,600 --> 00:02:16,940
At this point, like no one going to succeed, then the main function is going to get what it is, going

30
00:02:16,940 --> 00:02:19,700
to destroy all the objects that were created.

31
00:02:19,700 --> 00:02:21,230
So what are the objects that were created?

32
00:02:21,320 --> 00:02:22,460
There is a camera object.

33
00:02:22,940 --> 00:02:24,260
It is an old camera object.

34
00:02:24,710 --> 00:02:26,120
Both of them will be destroyed.

35
00:02:26,360 --> 00:02:28,070
And let's see this in action.

36
00:02:28,610 --> 00:02:31,720
This is going to hang up and automatically.

37
00:02:31,730 --> 00:02:35,390
We are not going to destroy it is going to handle automatically.

38
00:02:36,510 --> 00:02:42,870
You're going see the lighting, GoPro, it and the lighting GoPro Hero nine now when it says, OK,

39
00:02:42,870 --> 00:02:47,030
I'm going to delete these objects, it is basically going to delete these buckets.

40
00:02:47,070 --> 00:02:47,700
You know it.

41
00:02:48,720 --> 00:02:49,680
And Hero nine.

42
00:02:50,100 --> 00:02:55,650
OK, now these buckets also contained the address of a dynamically located memory.

43
00:02:56,630 --> 00:02:59,270
And that memory is not going to get deleted, OK?

44
00:03:00,760 --> 00:03:04,510
So this memory is not going to get deleted, so then you are deleted.

45
00:03:05,020 --> 00:03:10,520
It is just going to delete this part of the memory, this part of the memory, the address of this was

46
00:03:10,540 --> 00:03:12,250
how this was rendered.

47
00:03:12,470 --> 00:03:13,720
Later, this was 200.

48
00:03:13,720 --> 00:03:14,560
This was 200.

49
00:03:15,280 --> 00:03:20,710
We we actually lost the address of this memory and this memory is lying unutilised.

50
00:03:20,710 --> 00:03:25,030
OK, so this actually creates a problem which is known as memory leak.

51
00:03:25,570 --> 00:03:25,810
OK.

52
00:03:26,380 --> 00:03:32,010
So if you want to become a great programmer, you should not write code that causes memory leaks.

53
00:03:32,590 --> 00:03:38,400
What we will do In order to handle these memory leaks, we will write the code inside the structure.

54
00:03:38,410 --> 00:03:42,880
That means when this object is going to be destroyed, we will talk.

55
00:03:42,880 --> 00:03:46,300
It will first destroy this memory, then we will destroy this object.

56
00:03:46,930 --> 00:03:48,520
That is something that we are going to do now.

57
00:03:49,540 --> 00:03:50,260
So you are doing it.

58
00:03:50,610 --> 00:03:56,140
You simply need to say delete the name and make a name.

59
00:03:56,560 --> 00:03:59,710
Want to know if name was not null?

60
00:03:59,950 --> 00:04:07,240
OK, if name was not an alleged breath, then let's delete the name Eddie and let us make the name pointer

61
00:04:07,330 --> 00:04:09,930
point to note that said.

62
00:04:10,700 --> 00:04:18,640
Now you won't see any change in the output, but at the memory level, those two areas have also been

63
00:04:18,820 --> 00:04:19,360
deleted.

64
00:04:19,360 --> 00:04:19,650
OK?

65
00:04:19,690 --> 00:04:25,480
So again, the same destructor is getting called, and those two errors also have been deleted.

66
00:04:25,870 --> 00:04:29,670
So that's the concept of destructor and why do we need it?

67
00:04:29,700 --> 00:04:34,660
We needed to avoid memory leaks when the memory is allocated dynamically.

68
00:04:35,140 --> 00:04:36,980
So that's all for this lecture.

69
00:04:37,000 --> 00:04:37,510
Thank you.
